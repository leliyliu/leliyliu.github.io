<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="ONE程序代码简析,">










<meta name="description" content="[TOC] ONE程序代码简析 Routing所有的路由的实现都基于了MessageRouter这个基本的抽象类，所以我们首先关注这个抽象类 MessageRouter这是一个抽象类，使用了public abstract class 来进行声明。其主要定义了如下变量，主要包括了buffer size , TTL 和传输队列，包括传输和接收的信息反馈等。 1234567891011121314151">
<meta name="keywords" content="ONE程序代码简析">
<meta property="og:type" content="article">
<meta property="og:title" content="the-one-code-3">
<meta property="og:url" content="http://leliyliu.github.io/2020/03/31/the-one-code-3/index.html">
<meta property="og:site_name" content="禾声">
<meta property="og:description" content="[TOC] ONE程序代码简析 Routing所有的路由的实现都基于了MessageRouter这个基本的抽象类，所以我们首先关注这个抽象类 MessageRouter这是一个抽象类，使用了public abstract class 来进行声明。其主要定义了如下变量，主要包括了buffer size , TTL 和传输队列，包括传输和接收的信息反馈等。 1234567891011121314151">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-03-31T07:57:34.938Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="the-one-code-3">
<meta name="twitter:description" content="[TOC] ONE程序代码简析 Routing所有的路由的实现都基于了MessageRouter这个基本的抽象类，所以我们首先关注这个抽象类 MessageRouter这是一个抽象类，使用了public abstract class 来进行声明。其主要定义了如下变量，主要包括了buffer size , TTL 和传输队列，包括传输和接收的信息反馈等。 1234567891011121314151">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://leliyliu.github.io/2020/03/31/the-one-code-3/">





  <title>the-one-code-3 | 禾声</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">禾声</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">in the arm of the angel, fly away</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://leliyliu.github.io/2020/03/31/the-one-code-3/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leliyliu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="禾声">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">the-one-code-3</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-31T15:55:26+08:00">
                2020-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h1 id="ONE程序代码简析"><a href="#ONE程序代码简析" class="headerlink" title="ONE程序代码简析"></a>ONE程序代码简析</h1><hr>
<h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>所有的路由的实现都基于了<code>MessageRouter</code>这个基本的抽象类，所以我们首先关注这个抽象类</p>
<h3 id="MessageRouter"><a href="#MessageRouter" class="headerlink" title="MessageRouter"></a>MessageRouter</h3><p>这是一个抽象类，使用了public abstract class 来进行声明。其主要定义了如下变量，主要包括了buffer size , TTL 和传输队列，包括传输和接收的信息反馈等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//message buffer size </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String B_SIZE_S = <span class="string">"bufferSize"</span>;</span><br><span class="line"><span class="comment">//TTL 即最多能够传递的次数 (time to live)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MSG_TTL_S = <span class="string">"msgTtl"</span>;</span><br><span class="line"><span class="comment">//如果路由协议没有定义任何特殊的传输message 的序列，那么这将影响传输的顺序；也就是信息传输队列的类型。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SEND_QUEUE_MODE_S = <span class="string">"sendQueue"</span>;</span><br><span class="line"><span class="comment">/** Setting value for random queue mode */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Q_MODE_RANDOM = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** Setting value for FIFO queue mode */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Q_MODE_FIFO = <span class="number">2</span>;</span><br><span class="line"><span class="comment">/** Setting string for random queue mode */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STR_Q_MODE_RANDOM = <span class="string">"RANDOM"</span>;</span><br><span class="line"><span class="comment">/** Setting string for FIFO queue mode */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STR_Q_MODE_FIFO = <span class="string">"FIFO"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Receive return value for OK */</span></span><br><span class="line"><span class="comment">//当开始传输的时候，返回的结果 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RCV_OK = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** Receive return value for busy receiver */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRY_LATER_BUSY = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** Receive return value for an old (already received) message */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DENIED_OLD = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/** Receive return value for not enough space in the buffer for the msg */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DENIED_NO_SPACE = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">/** Receive return value for messages whose TTL has expired */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DENIED_TTL = -<span class="number">3</span>;</span><br><span class="line"><span class="comment">/** Receive return value for a node low on some resource(s) */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DENIED_LOW_RESOURCES = -<span class="number">4</span>;</span><br><span class="line"><span class="comment">/** Receive return value for a node low on some resource(s) */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DENIED_POLICY = -<span class="number">5</span>;</span><br><span class="line"><span class="comment">/** Receive return value for unspecified reason */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DENIED_UNSPECIFIED = -<span class="number">99</span>;</span><br><span class="line"><span class="comment">/** Maximum Ttl value */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_TTL_VALUE = <span class="number">35791394</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;MessageListener&gt; mListeners;</span><br><span class="line"><span class="comment">/** The messages being transferred with msgID_hostName keys */</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;String, Message&gt; incomingMessages;</span><br><span class="line"><span class="comment">/** The messages this router is carrying */</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;String, Message&gt; messages;</span><br><span class="line"><span class="comment">/** The messages this router has received as the final recipient */</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;String, Message&gt; deliveredMessages;</span><br><span class="line"><span class="comment">/** The messages that Applications on this router have blacklisted */</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;String, Object&gt; blacklistedMessages;</span><br><span class="line"><span class="comment">/** Host where this router belongs to */</span></span><br><span class="line"><span class="keyword">private</span> DTNHost host;</span><br><span class="line"><span class="comment">/** size of the buffer */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> bufferSize;</span><br><span class="line"><span class="comment">/** TTL for all messages */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> msgTtl;</span><br><span class="line"><span class="comment">/** Queue mode for sending messages */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sendQueueMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** applications attached to the host */</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;String, Collection&lt;Application&gt;&gt; applications = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>然后定义了如下的一些主要函数（方法）：</p>
<h4 id="MessageRouter-Setting-s"><a href="#MessageRouter-Setting-s" class="headerlink" title="MessageRouter(Setting s)"></a>MessageRouter(Setting s)</h4><p>根据配置文件<code>default_setting.txt</code>进行读取并创建相应的mesage router。</p>
<h4 id="init-DTNHost-List"><a href="#init-DTNHost-List" class="headerlink" title="init(DTNHost,List)"></a>init(DTNHost,List<messagelistener>)</messagelistener></h4><p>初始化一个router , 设定这个router 在具体的哪个host 当中 和当该router 发送消息时所有需要被通知的message listener 。</p>
<h4 id="update"><a href="#update" class="headerlink" title="update()"></a>update()</h4><p>当进行更新的时候，其实际上是向上层传递（应用层），然后让相应需要更新的应用层进行更新。</p>
<h4 id="sendMessage-String-DTNHost"><a href="#sendMessage-String-DTNHost" class="headerlink" title="sendMessage(String , DTNHost)"></a>sendMessage(String , DTNHost)</h4><p>在这里比较需要进行关注的点在于，要发送的信息不能是当前信息，而需要对其进行拷贝：<code>m2 = m.replicate()</code>，然后再进行发送。包括在receiveMessage中也会进行相应的拷贝，要注意这一含义，否则则有可能进行了深拷贝，那么message进行修改的时候就会导致相应的错误。</p>
<h4 id="messageTransferred"><a href="#messageTransferred" class="headerlink" title="messageTransferred()"></a>messageTransferred()</h4><p>通过判断当前接收到的message是否是到达目的地，来决定是否要进行转发，同时会调用到上层的application 来决定其是否需要drop掉它。</p>
<h4 id="sortByQueueMode"><a href="#sortByQueueMode" class="headerlink" title="sortByQueueMode"></a>sortByQueueMode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(value = <span class="string">"unchecked"</span>) <span class="comment">/* ugly way to make this generic */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List <span class="title">sortByQueueMode</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (sendQueueMode) &#123;</span><br><span class="line">	<span class="keyword">case</span> Q_MODE_RANDOM:</span><br><span class="line">		Collections.shuffle(list, <span class="keyword">new</span> Random(SimClock.getIntTime()));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> Q_MODE_FIFO:</span><br><span class="line">		Collections.sort(list,</span><br><span class="line">				<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">			<span class="comment">/** Compares two tuples by their messages' receiving time */</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">double</span> diff;</span><br><span class="line">				Message m1, m2;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Tuple) &#123;</span><br><span class="line">					m1 = ((Tuple&lt;Message, Connection&gt;)o1).getKey();</span><br><span class="line">					m2 = ((Tuple&lt;Message, Connection&gt;)o2).getKey();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Message) &#123;</span><br><span class="line">					m1 = (Message)o1;</span><br><span class="line">					m2 = (Message)o2;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> SimError(<span class="string">"Invalid type of objects in "</span> +</span><br><span class="line">							<span class="string">"the list"</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				diff = m1.getReceiveTime() - m2.getReceiveTime();</span><br><span class="line">				<span class="keyword">if</span> (diff == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> (diff &lt; <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">/* add more queue modes here */</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> SimError(<span class="string">"Unknown queue mode "</span> + sendQueueMode);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这里根据两种不同的方式 Q_MODE_RANDOM 和Q_MODE_FIFO 来进行的排序。同样的 compare  也是依据这两种不同模式来分别进行比较的。</p>
<h3 id="ActiveRouter"><a href="#ActiveRouter" class="headerlink" title="ActiveRouter"></a>ActiveRouter</h3><p>主动路由的超类（实际上是被动路由），继承自MessageRouter。</p>
<h4 id="update-1"><a href="#update-1" class="headerlink" title="update()"></a>update()</h4><p>关于更新，主要分为了这样几步，首先是调用了MessageRouter 实现的update函数，然后查找所有的<code>sendingConnections</code>，然后检测该<code>connection</code>是否已经传输过信息，根据此决定是否是否已经传输完成(transferDone)，如果当前的<code>connection</code>已经关闭，那么就abort掉，如果有需要进行remove的，那么根据相应的信息进行移除，最后将已经过期的信息从当前的buffer中移除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.update();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* in theory we can have multiple sending connections even though</span></span><br><span class="line"><span class="comment">	  currently all routers allow only one concurrent sending connection */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.sendingConnections.size(); ) &#123;</span><br><span class="line">		<span class="keyword">boolean</span> removeCurrent = <span class="keyword">false</span>;</span><br><span class="line">		Connection con = sendingConnections.get(i);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* finalize ready transfers */</span></span><br><span class="line">		<span class="keyword">if</span> (con.isMessageTransferred()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (con.getMessage() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				transferDone(con);</span><br><span class="line">				con.finalizeTransfer();</span><br><span class="line">			&#125; <span class="comment">/* else: some other entity aborted transfer */</span></span><br><span class="line">			removeCurrent = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* remove connections that have gone down */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!con.isUp()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (con.getMessage() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				transferAborted(con);</span><br><span class="line">				con.abortTransfer();</span><br><span class="line">			&#125;</span><br><span class="line">			removeCurrent = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (removeCurrent) &#123;</span><br><span class="line">			<span class="comment">// if the message being sent was holding excess buffer, free it</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.getFreeBufferSize() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.makeRoomForMessage(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			sendingConnections.remove(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* index increase needed only if nothing was removed */</span></span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* time to do a TTL check and drop old messages? Only if not sending */</span></span><br><span class="line">	<span class="keyword">if</span> (SimClock.getTime() - lastTtlCheck &gt;= TTL_CHECK_INTERVAL &amp;&amp;</span><br><span class="line">			sendingConnections.size() == <span class="number">0</span>) &#123;</span><br><span class="line">		dropExpiredMessages();</span><br><span class="line">		lastTtlCheck = SimClock.getTime();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (energy != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">/* <span class="doctag">TODO:</span> add support for other interfaces */</span></span><br><span class="line">		NetworkInterface iface = getHost().getInterface(<span class="number">1</span>);</span><br><span class="line">		energy.update(iface, getHost().getComBus());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PassiveRouter"><a href="#PassiveRouter" class="headerlink" title="PassiveRouter"></a>PassiveRouter</h3><p>PassiveRouter ， 实际上是我们所讲的主动路由，即不发送任何消息除非在需要的时候，即只有在需要发送message的时候才进行路由表的查找。这对于一些外部事件是比较有效的一种路由方式，同样地，其继承于<code>MessageRouter</code>。其没有增加任何相应的变量。</p>
<h3 id="DirectDeliveryRouter"><a href="#DirectDeliveryRouter" class="headerlink" title="DirectDeliveryRouter"></a>DirectDeliveryRouter</h3><p>继承自ActiveRouter ，是一种具体的被动路由，路由器只会向最终的router 发送相应的message，而不是采用广播的方式进行。 这里只是对update进行了相应的补充，即如果正在传输或者当前路由无法传输，不需要更新；然后去检测是否能到最终的接收方，并根据此进行判断。</p>
<h3 id="EpidemicOracleRouter"><a href="#EpidemicOracleRouter" class="headerlink" title="EpidemicOracleRouter"></a>EpidemicOracleRouter</h3><p>同样继承自ActiveRouter，这个router 利用相应的数据库保存了message是何时被传输的，并且何时被所有节点移除的。（所有使用该路由的节点）。所有信息都是立即发出。</p>
<p>其增加了一个新的变量<code>List&lt;EpidemicOracleRouter&gt; allRouters</code>，来记录所有使用该路由的节点。</p>
<p><strong>注意此处</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EpidemicOracleRouter</span><span class="params">(Settings s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r The router prototype where setting values are copied from</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">EpidemicOracleRouter</span><span class="params">(EpidemicOracleRouter r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(r);</span><br><span class="line">	allRouters.add(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用setting  进行初始化的时候没有调用<code>allRouters.add(this)</code>，因为利用setting 进行初始化的时候实际上可以视作建立的是一个template，只用于后面的其它路由的建立。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">messageTransferred</span><span class="params">(String id, DTNHost from)</span> </span>&#123;</span><br><span class="line">	Message m = <span class="keyword">super</span>.messageTransferred(id, from);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m.getTo() == <span class="keyword">this</span>.getHost()) &#123;</span><br><span class="line">		<span class="keyword">for</span> (EpidemicOracleRouter r : allRouters) &#123;</span><br><span class="line">			<span class="keyword">if</span> (r != <span class="keyword">this</span> &amp;&amp; r != from.getRouter()) &#123;</span><br><span class="line">				r.removeDeliveredMessage(id);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sendMessageToConnected(m);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的实现，主要是多加了这样一个部分，即当到达的时候-&gt; (m.getTo() == this.getHost())，那么就删掉所有不是该路由自身或者传递过来的路由的其它路由的相应该信息，否则就传递给connection。</p>
<h3 id="EpidemicRouter"><a href="#EpidemicRouter" class="headerlink" title="EpidemicRouter"></a>EpidemicRouter</h3><p>每次只有单个的传输连接，并且会抛弃之前的buffer中的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.update();</span><br><span class="line">	<span class="keyword">if</span> (isTransferring() || !canStartTransfer()) &#123;</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// transferring, don't try other connections yet</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Try first the messages that can be delivered to final recipient</span></span><br><span class="line">	<span class="keyword">if</span> (exchangeDeliverableMessages() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// started a transfer, don't try others (yet)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// then try any/all message to any/all connection</span></span><br><span class="line">	<span class="keyword">this</span>.tryAllMessagesToAllConnections();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其首先会尝试传输给最终需要接收的节点，如果无法直接传输到，那么就会传给所有相应的connections，相当于是一个广播的方式。</p>
<h3 id="FirstContactRouter"><a href="#FirstContactRouter" class="headerlink" title="FirstContactRouter"></a>FirstContactRouter</h3><p>这个router 只用message 的一个copy 来进行传输，一直到第一个可用的contact。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">checkReceiving</span><span class="params">(Message m, DTNHost from)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> recvCheck = <span class="keyword">super</span>.checkReceiving(m, from);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (recvCheck == RCV_OK) &#123;</span><br><span class="line">		<span class="comment">/* don't accept a message that has already traversed this node */</span></span><br><span class="line">		<span class="keyword">if</span> (m.getHops().contains(getHost())) &#123;</span><br><span class="line">			recvCheck = DENIED_OLD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> recvCheck;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于是first contact ，所以只接收一次相关的message，而不是每次都接收。</p>
<h3 id="LifeRouter"><a href="#LifeRouter" class="headerlink" title="LifeRouter"></a>LifeRouter</h3><p> Router module mimicking the game-of-life behavior， 也就是模拟game-of-life 的方式来进行route。 </p>
<p>新增加了两个变量： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NM_COUNT_S = <span class="string">"nmcount"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> countRange[];</span><br></pre></td></tr></table></figure>
<p><code>nmcount</code>指的是neighboring message count , <code>count_range</code>是一个最小值和最大值，并且用逗号分开。</p>
<p>实现了一个新的函数：<code>getPeerMessageCount(Message m)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPeerMessageCount</span><span class="params">(Message m)</span> </span>&#123;</span><br><span class="line">	DTNHost me = getHost();</span><br><span class="line">	String id = m.getId();</span><br><span class="line">	<span class="keyword">int</span> peerMsgCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (Connection c : getConnections()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c.getOtherNode(me).getRouter().hasMessage(id)) &#123;</span><br><span class="line">			peerMsgCount++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> peerMsgCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算有多少个connected peers 拥有这个Message</p>
<p>对于update 函数而言，其为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> peerMsgCount;</span><br><span class="line">	Vector&lt;String&gt; messagesToDelete = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">	<span class="keyword">super</span>.update();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isTransferring() || !canStartTransfer()) &#123;</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">/* transferring, don't try other connections yet */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Try first the messages that can be delivered to final recipient */</span></span><br><span class="line">	<span class="keyword">if</span> (exchangeDeliverableMessages() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>.tryAllMessagesToAllConnections();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* see if need to drop some messages... */</span></span><br><span class="line">	<span class="keyword">for</span> (Message m : getMessageCollection()) &#123;</span><br><span class="line">		peerMsgCount = getPeerMessageCount(m);</span><br><span class="line">		<span class="keyword">if</span> (peerMsgCount &lt; <span class="keyword">this</span>.countRange[<span class="number">0</span>] ||</span><br><span class="line">				peerMsgCount &gt; <span class="keyword">this</span>.countRange[<span class="number">1</span>]) &#123;</span><br><span class="line">			messagesToDelete.add(m.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (String id : messagesToDelete) &#123; <span class="comment">/* ...and drop them */</span></span><br><span class="line">		<span class="keyword">this</span>.deleteMessage(id, <span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟前一个而言，其最大的不同在于需要检查是否需要drop 相应的message，即看当前的message 是否超过了设定的范围，如果超过了相应的范围，就会有：<code>messagesToDelete</code></p>
<h3 id="MaxPropRouter"><a href="#MaxPropRouter" class="headerlink" title="MaxPropRouter"></a>MaxPropRouter</h3><p>这是一种基于车联网的路由方式，是一种能够disruption-tolerant 的网络。同样继承自ActiveRouter，这个协议的扩展是通过添加一个参数$\alpha$来进行实现的。对于一个新的connection， 它的传递的可能性为 $\frac{\alpha \times p}{1+\alpha}$。</p>
<h4 id="新增变量"><a href="#新增变量" class="headerlink" title="新增变量"></a>新增变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// setting 文件中的名字空间 (name)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAXPROP_NS = <span class="string">"MaxPropRouter"</span>;</span><br><span class="line"><span class="comment">// 传递可能性的最大值的设定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROB_SET_MAX_SIZE_S = <span class="string">"probSetMaxSize"</span>;</span><br><span class="line"><span class="comment">// 一个default 的值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PROB_SET_MAX_SIZE = <span class="number">50</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> probSetMaxSize;</span><br><span class="line"><span class="comment">//MeetingProbabilitySet 声明的位置为 routing.maxprop 中，</span></span><br><span class="line"><span class="comment">//其主要是为了来保存和进行关于meeting probability 的操作</span></span><br><span class="line"><span class="comment">//最主要的，包括了一个Map&lt;Integer,Double&gt; 也就是相应下一个结点的连接可能性。</span></span><br><span class="line"><span class="keyword">private</span> MeetingProbabilitySet probs;</span><br><span class="line"><span class="comment">//进行相应的映射</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer, MeetingProbabilitySet&gt; allProbs;</span><br><span class="line"><span class="comment">/** the cost-to-node calculator Dijkstra 算法*/</span></span><br><span class="line"><span class="keyword">private</span> MaxPropDijkstra dijkstra;</span><br><span class="line"><span class="comment">/** IDs of the messages that are known to have reached the final dst */</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; ackedMessageIds;</span><br><span class="line"><span class="comment">/** message(key) -&gt; cost(value) */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer, Double&gt; costsForMessages;</span><br><span class="line"><span class="comment">/** From host of the last cost calculation */</span></span><br><span class="line"><span class="keyword">private</span> DTNHost lastCostFrom;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**记录了向哪些host 发送了具体的哪些message */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;DTNHost, Set&lt;String&gt;&gt; sentMessages;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每次传输机会，能够传输的平均bytes	（采样）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> BYTES_TRANSFERRED_AVG_SAMPLES = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] avgSamples;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> nextSampleIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前的一个value 值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> avgTransferredBytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The alpha parameter string*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALPHA_S = <span class="string">"alpha"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The alpha variable, default = 1;*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> alpha;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default value for alpha */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> DEFAULT_ALPHA = <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure>
<p>新增的变量，主要是为了实现相应的传播可能性的计算，以及所传输的相应信息，包括传送到的具体位置，以及传输的平均bytes（每次传输机会）。</p>
<p>对于此，有一些相应的补充，即为了实现<code>MaxPropRouter</code>而实现的两个相应类，具体在<code>routing.maxprop</code>的package之中，具体为下：</p>
<h5 id="MeetingProbabilitySet"><a href="#MeetingProbabilitySet" class="headerlink" title="MeetingProbabilitySet"></a>MeetingProbabilitySet</h5><p>这个类主要是为了存储和对<code>meeting probabilities</code>的进行操作。</p>
<p>其中一个最重要的函数为<code>updateMeetingProbFor()</code>，其具体作用是更新meeting probability 对于一个给定的node index。 </p>
<p>可以看到，对于第一个，其可能性为1 ，如果某个结点node 进行了更新，那么其会增加，但是为了保证所有的可能性之和为1，所以会除以$\alpha + 1$，最后做了一个异常的处理，即超出相应的范围。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateMeetingProbFor</span><span class="params">(Integer index)</span> </span>&#123;</span><br><span class="line">       Map.Entry&lt;Integer, Double&gt; smallestEntry = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">double</span> smallestValue = Double.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.lastUpdateTime = SimClock.getTime();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (probs.size() == <span class="number">0</span>) &#123; <span class="comment">// first entry</span></span><br><span class="line">		probs.put(index, <span class="number">1.0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> newValue = getProbFor(index) + alpha;</span><br><span class="line">	probs.put(index, newValue);</span><br><span class="line">	<span class="comment">/* now the sum of all entries is 1+alpha;</span></span><br><span class="line"><span class="comment">	 * normalize to one by dividing all the entries by 1+alpha */</span></span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;Integer, Double&gt; entry : probs.entrySet()) &#123;</span><br><span class="line">		entry.setValue(entry.getValue() / (<span class="number">1</span>+alpha));</span><br><span class="line">           <span class="keyword">if</span> (entry.getValue() &lt; smallestValue) &#123;</span><br><span class="line">               smallestEntry = entry;</span><br><span class="line">               smallestValue = entry.getValue();</span><br><span class="line">           &#125;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="keyword">if</span> (probs.size() &gt;= maxSetSize) &#123;</span><br><span class="line">           <span class="keyword">if</span> (DEBUG) core.Debug.p(<span class="string">"Probsize: "</span> + probs.size() + <span class="string">" dropping "</span> +</span><br><span class="line">				probs.remove(smallestEntry.getKey()));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="MaxPropDijkstra"><a href="#MaxPropDijkstra" class="headerlink" title="MaxPropDijkstra"></a>MaxPropDijkstra</h5><p>这个类，实际上就很简单，其实就是利用相应的信息，使用dijkstra算法去找到最短的路径。其中，一个重要的函数时<code>relax(Integer)</code>函数，其作用就是relax 一个结点的所有邻居，即更新最短路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(Integer node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> nodeDist = distancesFromStart.get(node);</span><br><span class="line">	Collection&lt;Integer&gt; neighbors;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.probs.containsKey(node)) &#123;</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// node's neighbors are not known</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	neighbors =	<span class="keyword">this</span>.probs.get(node).getAllProbs().keySet();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (Integer n : neighbors) &#123;</span><br><span class="line">		<span class="keyword">if</span> (visited.contains(n)) &#123;</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">// skip visited nodes</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// n node's distance from path's source node</span></span><br><span class="line">		<span class="keyword">double</span> nDist = nodeDist + getDistance(node, n);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (distancesFromStart.get(n) &gt; nDist) &#123;</span><br><span class="line">			<span class="comment">// stored distance &gt; found dist -&gt; update</span></span><br><span class="line">			prevNodes.put(n, node); <span class="comment">// for debugging</span></span><br><span class="line">			setDistance(n, nDist);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，首先需要得到当前的neighbors，然后去检查是否其已经被访问过，否则进行相应的distance 的更新，然后去判断是否当前是最短路径，如果是，那么进行修改。实际上就是一个Dijkstra算法的具体情况下的实现。</p>
<h3 id="MaxPropRouterWithEstimation"><a href="#MaxPropRouterWithEstimation" class="headerlink" title="MaxPropRouterWithEstimation"></a>MaxPropRouterWithEstimation</h3><p>这个路由协议和MaxPropRouter最大的不同在于其通过参数估计(估计alpha)来找到一个合适的值，基于时间量程的定义(timescale definition)，对于整个其它方面，其和MaxPropRouter具有相同的含义</p>
<p>其一个最重要的函数时<code>updateParam()</code></p>
<h4 id="updateParam"><a href="#updateParam" class="headerlink" title="updateParam()"></a>updateParam()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updateParam</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> err = .<span class="number">01</span>;</span><br><span class="line">	<span class="keyword">double</span> ntarg = Math.ceil(timescale/meanIET);</span><br><span class="line">	<span class="keyword">double</span> ee = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">double</span> alphadiff = .<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> ob = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">double</span> fstable;</span><br><span class="line">	<span class="keyword">double</span> fnzero;</span><br><span class="line">	<span class="keyword">double</span> fnone;</span><br><span class="line">	<span class="keyword">double</span> eezero;</span><br><span class="line">	<span class="keyword">double</span> eeone;</span><br><span class="line">	<span class="keyword">double</span> A;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * the estimation algorith does not work for timescales</span></span><br><span class="line"><span class="comment">	 * shorter than the mean IET - so use defaults</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (meanIET &gt; (<span class="keyword">double</span>)timescale) &#123;</span><br><span class="line">		System.out.printf(<span class="string">"meanIET %f &gt; %d timescale\n"</span>,meanIET,timescale);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (meanIET == <span class="number">0</span>) &#123;</span><br><span class="line">		System.out.printf(<span class="string">"Mean IET == 0\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (meanENC == <span class="number">0</span>) &#123;</span><br><span class="line">		System.out.printf(<span class="string">"Mean ENC == 0\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ee != err) &#123;</span><br><span class="line">		A = Math.pow(<span class="number">1</span>+alpha,meanENC+<span class="number">1</span>);</span><br><span class="line">		fstable = alpha/(A-<span class="number">1</span>);</span><br><span class="line">		fnzero = (alpha/A)*(<span class="number">1</span>-Math.pow(A,-ntarg))/(<span class="number">1</span>-<span class="number">1</span>/A);</span><br><span class="line">		fnone  = fnzero + <span class="number">1</span>/(Math.pow(A,ntarg));</span><br><span class="line">		eezero = Math.abs(fnzero-fstable);</span><br><span class="line">		eeone  = Math.abs(fnone -fstable);</span><br><span class="line">		ee = Math.max(eezero,eeone);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ee &gt; err ) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ob == <span class="number">2</span>) &#123;</span><br><span class="line">				alphadiff = alphadiff / <span class="number">2.0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ob = <span class="number">1</span>;</span><br><span class="line">			alpha = alpha+alphadiff;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (ee &lt; (err-err*<span class="number">0.001</span>)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (ob == <span class="number">1</span>) &#123;</span><br><span class="line">					alphadiff = alphadiff / <span class="number">2.0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				ob = <span class="number">2</span>;</span><br><span class="line">				alpha = alpha - alphadiff;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// double precision floating makes problems...</span></span><br><span class="line">				<span class="keyword">if</span> ((alpha &lt;= <span class="number">0</span>) | (((<span class="number">1</span> + alpha) - <span class="number">1</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">					alpha = alphadiff;</span><br><span class="line">					alphadiff = alphadiff / <span class="number">2.0</span>;</span><br><span class="line">					ob = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ee = err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	probs.setAlpha(alpha);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一段中，其主要的重点在于while循环中，即<code>while(ee!=eer)</code>，总体而言，即通过对于meanENC 和 alphadiff  等参数来估计，最终设定所得到的<code>alpha</code>。</p>
<h3 id="ProphetRouter"><a href="#ProphetRouter" class="headerlink" title="ProphetRouter"></a>ProphetRouter</h3><p>实现的是PRoPHET 路由算法，同样基于的是ActiveRouter。</p>
<h4 id="新增变量-1"><a href="#新增变量-1" class="headerlink" title="新增变量"></a>新增变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> P_INIT = <span class="number">0.75</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> DEFAULT_BETA = <span class="number">0.25</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> DEFAULT_GAMMA = <span class="number">0.98</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPHET_NS = <span class="string">"ProphetRouter"</span>;</span><br><span class="line"><span class="comment">// 在time unit 中seconds 的数目，需要根据scenario进行相应的调整。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECONDS_IN_UNIT_S =<span class="string">"secondsInTimeUnit"</span>;</span><br><span class="line"><span class="comment">//固定的传输比例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BETA_S = <span class="string">"beta"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相应的衰减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GAMMA_S = <span class="string">"gamma"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** the value of nrof seconds in time unit -setting */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> secondsInTimeUnit;</span><br><span class="line"><span class="comment">/** value of beta setting */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> beta;</span><br><span class="line"><span class="comment">/** value of gamma setting */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> gamma;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** delivery predictabilities */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;DTNHost, Double&gt; preds;</span><br><span class="line"><span class="comment">/** last delivery predictability update (sim)time */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> lastAgeUpdate;</span><br></pre></td></tr></table></figure>
<p>总体而言，其主要增加了这样几个不同的量，即<code>secondsInTimeUnit</code> 以及 $\beta \quad \gamma$，以及最后增加的一个Map，和一个记录最后一次更新的时间。 </p>
<h4 id="updateDeliveryPredFor"><a href="#updateDeliveryPredFor" class="headerlink" title="updateDeliveryPredFor()"></a>updateDeliveryPredFor()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateDeliveryPredFor</span><span class="params">(DTNHost host)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> oldValue = getPredFor(host);</span><br><span class="line">	<span class="keyword">double</span> newValue = oldValue + (<span class="number">1</span> - oldValue) * P_INIT;</span><br><span class="line">	preds.put(host, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这是对于delivery preictions 的相应更新实际上是： $P(a,b) = P(a,b)_{old} + (1-P(a,b)_{old}) \times P_INT$</p>
<h4 id="updateTransitivePreds"><a href="#updateTransitivePreds" class="headerlink" title="updateTransitivePreds()"></a>updateTransitivePreds()</h4><p>关于transitive ，其具体是这样一种方式，即(A-&gt;B-&gt;C) 的传输，对于其相应的predictions的计算，具体为：$P(a,c) = P(a,c)_{old} + (1 - P(a,c)_{old}) <em> P(a,b) </em> P(b,c) * \beta$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateTransitivePreds</span><span class="params">(DTNHost host)</span> </span>&#123;</span><br><span class="line">	MessageRouter otherRouter = host.getRouter();</span><br><span class="line">	<span class="keyword">assert</span> otherRouter <span class="keyword">instanceof</span> ProphetRouter : <span class="string">"PRoPHET only works "</span> +</span><br><span class="line">		<span class="string">" with other routers of same type"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> pForHost = getPredFor(host); <span class="comment">// P(a,b)</span></span><br><span class="line">	Map&lt;DTNHost, Double&gt; othersPreds =</span><br><span class="line">		((ProphetRouter)otherRouter).getDeliveryPreds();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;DTNHost, Double&gt; e : othersPreds.entrySet()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (e.getKey() == getHost()) &#123;</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">// don't add yourself</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">double</span> pOld = getPredFor(e.getKey()); <span class="comment">// P(a,c)_old</span></span><br><span class="line">		<span class="keyword">double</span> pNew = pOld + ( <span class="number">1</span> - pOld) * pForHost * e.getValue() * beta;</span><br><span class="line">		preds.put(e.getKey(), pNew);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对于delivery 和 transitive的更新和相应的衰减(age)，基于了两个相应的参数，即$\beta 和 \gamma$，以及$P_INT$</p>
<h3 id="ProphetRouterWithEstimation"><a href="#ProphetRouterWithEstimation" class="headerlink" title="ProphetRouterWithEstimation"></a>ProphetRouterWithEstimation</h3><p>这个版本和上面所给出的ProphetRouter  的不同在于其尝试通过估计来得到一个好的值。 其具体实现函数为<code>updateParam()</code>，具体内容可以参考源码，可以通过其更新<code>pinit</code>,<code>gamma</code>。</p>
<h3 id="ProphetV2Router"><a href="#ProphetV2Router" class="headerlink" title="ProphetV2Router"></a>ProphetV2Router</h3><p>关于这一个路由协议，可以具体参看：<a href="http://tools.ietf.org/html/draft-irtf-dtnrg-prophet-09" target="_blank" rel="noopener">http://tools.ietf.org/html/draft-irtf-dtnrg-prophet-09</a></p>
<h3 id="SprayAndWaitRouter"><a href="#SprayAndWaitRouter" class="headerlink" title="SprayAndWaitRouter"></a>SprayAndWaitRouter</h3><h3 id="WaveRouter"><a href="#WaveRouter" class="headerlink" title="WaveRouter"></a>WaveRouter</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ONE程序代码简析/" rel="tag"># ONE程序代码简析</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/30/the-one-code-2/" rel="next" title="the-one-code-2">
                <i class="fa fa-chevron-left"></i> the-one-code-2
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/09/the-one-code-4/" rel="prev" title="the-one-code-4">
                the-one-code-4 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Leliyliu</p>
              <p class="site-description motion-element" itemprop="description">record</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ONE程序代码简析"><span class="nav-number">1.</span> <span class="nav-text">ONE程序代码简析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Routing"><span class="nav-number">1.1.</span> <span class="nav-text">Routing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MessageRouter"><span class="nav-number">1.1.1.</span> <span class="nav-text">MessageRouter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MessageRouter-Setting-s"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">MessageRouter(Setting s)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#init-DTNHost-List"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">init(DTNHost,List)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#update"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">update()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sendMessage-String-DTNHost"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">sendMessage(String , DTNHost)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#messageTransferred"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">messageTransferred()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sortByQueueMode"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">sortByQueueMode</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ActiveRouter"><span class="nav-number">1.1.2.</span> <span class="nav-text">ActiveRouter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#update-1"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">update()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PassiveRouter"><span class="nav-number">1.1.3.</span> <span class="nav-text">PassiveRouter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DirectDeliveryRouter"><span class="nav-number">1.1.4.</span> <span class="nav-text">DirectDeliveryRouter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EpidemicOracleRouter"><span class="nav-number">1.1.5.</span> <span class="nav-text">EpidemicOracleRouter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EpidemicRouter"><span class="nav-number">1.1.6.</span> <span class="nav-text">EpidemicRouter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FirstContactRouter"><span class="nav-number">1.1.7.</span> <span class="nav-text">FirstContactRouter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LifeRouter"><span class="nav-number">1.1.8.</span> <span class="nav-text">LifeRouter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MaxPropRouter"><span class="nav-number">1.1.9.</span> <span class="nav-text">MaxPropRouter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新增变量"><span class="nav-number">1.1.9.1.</span> <span class="nav-text">新增变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MeetingProbabilitySet"><span class="nav-number">1.1.9.1.1.</span> <span class="nav-text">MeetingProbabilitySet</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MaxPropDijkstra"><span class="nav-number">1.1.9.1.2.</span> <span class="nav-text">MaxPropDijkstra</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MaxPropRouterWithEstimation"><span class="nav-number">1.1.10.</span> <span class="nav-text">MaxPropRouterWithEstimation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#updateParam"><span class="nav-number">1.1.10.1.</span> <span class="nav-text">updateParam()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProphetRouter"><span class="nav-number">1.1.11.</span> <span class="nav-text">ProphetRouter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新增变量-1"><span class="nav-number">1.1.11.1.</span> <span class="nav-text">新增变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#updateDeliveryPredFor"><span class="nav-number">1.1.11.2.</span> <span class="nav-text">updateDeliveryPredFor()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#updateTransitivePreds"><span class="nav-number">1.1.11.3.</span> <span class="nav-text">updateTransitivePreds()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProphetRouterWithEstimation"><span class="nav-number">1.1.12.</span> <span class="nav-text">ProphetRouterWithEstimation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProphetV2Router"><span class="nav-number">1.1.13.</span> <span class="nav-text">ProphetV2Router</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SprayAndWaitRouter"><span class="nav-number">1.1.14.</span> <span class="nav-text">SprayAndWaitRouter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WaveRouter"><span class="nav-number">1.1.15.</span> <span class="nav-text">WaveRouter</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leliyliu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
