<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>坠落</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="record">
<meta property="og:type" content="website">
<meta property="og:title" content="坠落">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="坠落">
<meta property="og:description" content="record">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="坠落">
<meta name="twitter:description" content="record">
  
    <link rel="alternate" href="/atom.xml" title="坠落" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">坠落</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">do what you want to do</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-龙芯杯6" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/23/龙芯杯6/" class="article-date">
  <time datetime="2019-04-23T11:31:25.000Z" itemprop="datePublished">2019-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/23/龙芯杯6/">longxin_6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="龙芯杯备战4"><a href="#龙芯杯备战4" class="headerlink" title="龙芯杯备战4"></a>龙芯杯备战4</h1><h2 id="国科大试验系统迁移-LAB3-1"><a href="#国科大试验系统迁移-LAB3-1" class="headerlink" title="国科大试验系统迁移  LAB3-1"></a>国科大试验系统迁移  LAB3-1</h2><h3 id="代码对比"><a href="#代码对比" class="headerlink" title="代码对比"></a>代码对比</h3><h4 id="1-接口"><a href="#1-接口" class="headerlink" title="1.接口"></a>1.接口</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//机组cpu</span></span><br><span class="line"><span class="keyword">module</span> pipeline_cpu(  </span><br><span class="line">    <span class="keyword">input</span> clk,           </span><br><span class="line">    <span class="keyword">input</span> resetn,       </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//display data</span></span><br><span class="line">    <span class="keyword">input</span>  [ <span class="number">4</span>:<span class="number">0</span>] rf_addr,<span class="comment">//regfile 的测试地址（用于测试regfile)</span></span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">31</span>:<span class="number">0</span>] mem_addr,<span class="comment">//memory的地址，用于取出数据</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] rf_data,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] mem_data,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] IF_pc,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] IF_inst,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] ID_pc,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] EXE_pc,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] MEM_pc,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] WB_pc,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最后需要用来检测的数据（检测5级的valid信号以及wb的数据)</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] cpu_5_valid,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] HI_data,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] LO_data</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//国科大 CPU</span></span><br><span class="line"><span class="keyword">module</span> mycpu_top(</span><br><span class="line">	<span class="keyword">input</span>         clk,<span class="comment">//时钟</span></span><br><span class="line">	<span class="keyword">input</span>         resetn,<span class="comment">//复位信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ram  指令</span></span><br><span class="line">	<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>]  inst_sram_rdata,<span class="comment">//ram 读数据  -&gt; inst(所得到的指令)</span></span><br><span class="line">	<span class="keyword">output</span>        inst_sram_en,<span class="comment">//ram 使能信号   (需要自己添加这一信号的赋值)    ----&gt;还未修改</span></span><br><span class="line">	<span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>]  inst_sram_wen,<span class="comment">//ram 字节写使能信号 (在机组的流水线中，并未实现)  ---&gt; 还未修改</span></span><br><span class="line">	<span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] inst_sram_addr,<span class="comment">//ram 读写地址，字节寻址  -&gt; pc  (inst_addr)   </span></span><br><span class="line">	<span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] inst_sram_wdata,<span class="comment">//ram 写数据  (所需要修改的数据指令)    ---&gt; 还未修改</span></span><br><span class="line"><span class="comment">//ram  数据    -&gt;类似于inst_sram   可以直接在mem.v阶段使用</span></span><br><span class="line">	<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>]  data_sram_rdata,<span class="comment">//ram 读数据</span></span><br><span class="line">	<span class="keyword">output</span>        data_sram_en,<span class="comment">//ram 使能信号，高电平有效    ----&gt; 还未修改</span></span><br><span class="line">	<span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>]  data_sram_wen,<span class="comment">//ram 字节写使能信号</span></span><br><span class="line">	<span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] data_sram_addr,<span class="comment">//ram 读写地址</span></span><br><span class="line">	<span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] data_sram_wdata,<span class="comment">//ram 写数据 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] debug_wb_pc,<span class="comment">//wb级的PC，因而需要mycpu 的PC 一路带到写回级</span></span><br><span class="line">	<span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>]  debug_wb_rf_wen,<span class="comment">// 写回级写寄存器堆(regfiles) 的写使能，为字节写使能</span></span><br><span class="line">	<span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>]  debug_wb_rf_wnum,<span class="comment">// 写回级写regfiles的目的寄存器号</span></span><br><span class="line">	<span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] debug_wb_rf_wdata<span class="comment">// 写回级写regfiles的写数据</span></span><br><span class="line">	);</span><br></pre></td></tr></table></figure>
<h4 id="2-regfile"><a href="#2-regfile" class="headerlink" title="2.regfile"></a>2.regfile</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//regilfe 中原机组代码有test，但是由于在修改后的cpu后没有test的input信号，所以修改后直接删除就好</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="comment">//*************************************************************************</span></span><br><span class="line"><span class="comment">//  LOONGSON</span></span><br><span class="line"><span class="comment">//  2016-04-14</span></span><br><span class="line"><span class="comment">//*************************************************************************</span></span><br><span class="line"><span class="keyword">module</span> regfile(</span><br><span class="line">    <span class="keyword">input</span>             clk,</span><br><span class="line">    <span class="keyword">input</span>             wen,</span><br><span class="line">    <span class="keyword">input</span>      [<span class="number">4</span> :<span class="number">0</span>] raddr1,</span><br><span class="line">    <span class="keyword">input</span>      [<span class="number">4</span> :<span class="number">0</span>] raddr2,</span><br><span class="line">    <span class="keyword">input</span>      [<span class="number">4</span> :<span class="number">0</span>] waddr,</span><br><span class="line">    <span class="keyword">input</span>      [<span class="number">31</span>:<span class="number">0</span>] wdata,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] rdata1,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] rdata2,</span><br><span class="line">    <span class="keyword">input</span>      [<span class="number">4</span> :<span class="number">0</span>] test_addr,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] test_data</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] rf[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// three ported register file</span></span><br><span class="line">    <span class="comment">// read two ports combinationally</span></span><br><span class="line">    <span class="comment">// write third port on rising edge of clock</span></span><br><span class="line">    <span class="comment">// register 0 hardwired to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (wen) </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            rf[waddr] &lt;= wdata;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">always</span> @(*)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (raddr1)</span><br><span class="line">            <span class="number">5'd1</span> : rdata1 &lt;= rf[<span class="number">1</span> ];</span><br><span class="line">            <span class="number">5'd2</span> : rdata1 &lt;= rf[<span class="number">2</span> ];</span><br><span class="line">            <span class="number">5'd3</span> : rdata1 &lt;= rf[<span class="number">3</span> ];</span><br><span class="line">            <span class="number">5'd4</span> : rdata1 &lt;= rf[<span class="number">4</span> ];</span><br><span class="line">            <span class="number">5'd5</span> : rdata1 &lt;= rf[<span class="number">5</span> ];</span><br><span class="line">            <span class="number">5'd6</span> : rdata1 &lt;= rf[<span class="number">6</span> ];</span><br><span class="line">            <span class="number">5'd7</span> : rdata1 &lt;= rf[<span class="number">7</span> ];</span><br><span class="line">            <span class="number">5'd8</span> : rdata1 &lt;= rf[<span class="number">8</span> ];</span><br><span class="line">            <span class="number">5'd9</span> : rdata1 &lt;= rf[<span class="number">9</span> ];</span><br><span class="line">            <span class="number">5'd10</span>: rdata1 &lt;= rf[<span class="number">10</span>];</span><br><span class="line">            <span class="number">5'd11</span>: rdata1 &lt;= rf[<span class="number">11</span>];</span><br><span class="line">            <span class="number">5'd12</span>: rdata1 &lt;= rf[<span class="number">12</span>];</span><br><span class="line">            <span class="number">5'd13</span>: rdata1 &lt;= rf[<span class="number">13</span>];</span><br><span class="line">            <span class="number">5'd14</span>: rdata1 &lt;= rf[<span class="number">14</span>];</span><br><span class="line">            <span class="number">5'd15</span>: rdata1 &lt;= rf[<span class="number">15</span>];</span><br><span class="line">            <span class="number">5'd16</span>: rdata1 &lt;= rf[<span class="number">16</span>];</span><br><span class="line">            <span class="number">5'd17</span>: rdata1 &lt;= rf[<span class="number">17</span>];</span><br><span class="line">            <span class="number">5'd18</span>: rdata1 &lt;= rf[<span class="number">18</span>];</span><br><span class="line">            <span class="number">5'd19</span>: rdata1 &lt;= rf[<span class="number">19</span>];</span><br><span class="line">            <span class="number">5'd20</span>: rdata1 &lt;= rf[<span class="number">20</span>];</span><br><span class="line">            <span class="number">5'd21</span>: rdata1 &lt;= rf[<span class="number">21</span>];</span><br><span class="line">            <span class="number">5'd22</span>: rdata1 &lt;= rf[<span class="number">22</span>];</span><br><span class="line">            <span class="number">5'd23</span>: rdata1 &lt;= rf[<span class="number">23</span>];</span><br><span class="line">            <span class="number">5'd24</span>: rdata1 &lt;= rf[<span class="number">24</span>];</span><br><span class="line">            <span class="number">5'd25</span>: rdata1 &lt;= rf[<span class="number">25</span>];</span><br><span class="line">            <span class="number">5'd26</span>: rdata1 &lt;= rf[<span class="number">26</span>];</span><br><span class="line">            <span class="number">5'd27</span>: rdata1 &lt;= rf[<span class="number">27</span>];</span><br><span class="line">            <span class="number">5'd28</span>: rdata1 &lt;= rf[<span class="number">28</span>];</span><br><span class="line">            <span class="number">5'd29</span>: rdata1 &lt;= rf[<span class="number">29</span>];</span><br><span class="line">            <span class="number">5'd30</span>: rdata1 &lt;= rf[<span class="number">30</span>];</span><br><span class="line">            <span class="number">5'd31</span>: rdata1 &lt;= rf[<span class="number">31</span>];</span><br><span class="line">            <span class="keyword">default</span> : rdata1 &lt;= <span class="number">32'd0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">always</span> @(*)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (raddr2)</span><br><span class="line">            <span class="number">5'd1</span> : rdata2 &lt;= rf[<span class="number">1</span> ];</span><br><span class="line">            <span class="number">5'd2</span> : rdata2 &lt;= rf[<span class="number">2</span> ];</span><br><span class="line">            <span class="number">5'd3</span> : rdata2 &lt;= rf[<span class="number">3</span> ];</span><br><span class="line">            <span class="number">5'd4</span> : rdata2 &lt;= rf[<span class="number">4</span> ];</span><br><span class="line">            <span class="number">5'd5</span> : rdata2 &lt;= rf[<span class="number">5</span> ];</span><br><span class="line">            <span class="number">5'd6</span> : rdata2 &lt;= rf[<span class="number">6</span> ];</span><br><span class="line">            <span class="number">5'd7</span> : rdata2 &lt;= rf[<span class="number">7</span> ];</span><br><span class="line">            <span class="number">5'd8</span> : rdata2 &lt;= rf[<span class="number">8</span> ];</span><br><span class="line">            <span class="number">5'd9</span> : rdata2 &lt;= rf[<span class="number">9</span> ];</span><br><span class="line">            <span class="number">5'd10</span>: rdata2 &lt;= rf[<span class="number">10</span>];</span><br><span class="line">            <span class="number">5'd11</span>: rdata2 &lt;= rf[<span class="number">11</span>];</span><br><span class="line">            <span class="number">5'd12</span>: rdata2 &lt;= rf[<span class="number">12</span>];</span><br><span class="line">            <span class="number">5'd13</span>: rdata2 &lt;= rf[<span class="number">13</span>];</span><br><span class="line">            <span class="number">5'd14</span>: rdata2 &lt;= rf[<span class="number">14</span>];</span><br><span class="line">            <span class="number">5'd15</span>: rdata2 &lt;= rf[<span class="number">15</span>];</span><br><span class="line">            <span class="number">5'd16</span>: rdata2 &lt;= rf[<span class="number">16</span>];</span><br><span class="line">            <span class="number">5'd17</span>: rdata2 &lt;= rf[<span class="number">17</span>];</span><br><span class="line">            <span class="number">5'd18</span>: rdata2 &lt;= rf[<span class="number">18</span>];</span><br><span class="line">            <span class="number">5'd19</span>: rdata2 &lt;= rf[<span class="number">19</span>];</span><br><span class="line">            <span class="number">5'd20</span>: rdata2 &lt;= rf[<span class="number">20</span>];</span><br><span class="line">            <span class="number">5'd21</span>: rdata2 &lt;= rf[<span class="number">21</span>];</span><br><span class="line">            <span class="number">5'd22</span>: rdata2 &lt;= rf[<span class="number">22</span>];</span><br><span class="line">            <span class="number">5'd23</span>: rdata2 &lt;= rf[<span class="number">23</span>];</span><br><span class="line">            <span class="number">5'd24</span>: rdata2 &lt;= rf[<span class="number">24</span>];</span><br><span class="line">            <span class="number">5'd25</span>: rdata2 &lt;= rf[<span class="number">25</span>];</span><br><span class="line">            <span class="number">5'd26</span>: rdata2 &lt;= rf[<span class="number">26</span>];</span><br><span class="line">            <span class="number">5'd27</span>: rdata2 &lt;= rf[<span class="number">27</span>];</span><br><span class="line">            <span class="number">5'd28</span>: rdata2 &lt;= rf[<span class="number">28</span>];</span><br><span class="line">            <span class="number">5'd29</span>: rdata2 &lt;= rf[<span class="number">29</span>];</span><br><span class="line">            <span class="number">5'd30</span>: rdata2 &lt;= rf[<span class="number">30</span>];</span><br><span class="line">            <span class="number">5'd31</span>: rdata2 &lt;= rf[<span class="number">31</span>];</span><br><span class="line">            <span class="keyword">default</span> : rdata2 &lt;= <span class="number">32'd0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (test_addr)</span><br><span class="line">            <span class="number">5'd1</span> : test_data &lt;= rf[<span class="number">1</span> ];</span><br><span class="line">            <span class="number">5'd2</span> : test_data &lt;= rf[<span class="number">2</span> ];</span><br><span class="line">            <span class="number">5'd3</span> : test_data &lt;= rf[<span class="number">3</span> ];</span><br><span class="line">            <span class="number">5'd4</span> : test_data &lt;= rf[<span class="number">4</span> ];</span><br><span class="line">            <span class="number">5'd5</span> : test_data &lt;= rf[<span class="number">5</span> ];</span><br><span class="line">            <span class="number">5'd6</span> : test_data &lt;= rf[<span class="number">6</span> ];</span><br><span class="line">            <span class="number">5'd7</span> : test_data &lt;= rf[<span class="number">7</span> ];</span><br><span class="line">            <span class="number">5'd8</span> : test_data &lt;= rf[<span class="number">8</span> ];</span><br><span class="line">            <span class="number">5'd9</span> : test_data &lt;= rf[<span class="number">9</span> ];</span><br><span class="line">            <span class="number">5'd10</span>: test_data &lt;= rf[<span class="number">10</span>];</span><br><span class="line">            <span class="number">5'd11</span>: test_data &lt;= rf[<span class="number">11</span>];</span><br><span class="line">            <span class="number">5'd12</span>: test_data &lt;= rf[<span class="number">12</span>];</span><br><span class="line">            <span class="number">5'd13</span>: test_data &lt;= rf[<span class="number">13</span>];</span><br><span class="line">            <span class="number">5'd14</span>: test_data &lt;= rf[<span class="number">14</span>];</span><br><span class="line">            <span class="number">5'd15</span>: test_data &lt;= rf[<span class="number">15</span>];</span><br><span class="line">            <span class="number">5'd16</span>: test_data &lt;= rf[<span class="number">16</span>];</span><br><span class="line">            <span class="number">5'd17</span>: test_data &lt;= rf[<span class="number">17</span>];</span><br><span class="line">            <span class="number">5'd18</span>: test_data &lt;= rf[<span class="number">18</span>];</span><br><span class="line">            <span class="number">5'd19</span>: test_data &lt;= rf[<span class="number">19</span>];</span><br><span class="line">            <span class="number">5'd20</span>: test_data &lt;= rf[<span class="number">20</span>];</span><br><span class="line">            <span class="number">5'd21</span>: test_data &lt;= rf[<span class="number">21</span>];</span><br><span class="line">            <span class="number">5'd22</span>: test_data &lt;= rf[<span class="number">22</span>];</span><br><span class="line">            <span class="number">5'd23</span>: test_data &lt;= rf[<span class="number">23</span>];</span><br><span class="line">            <span class="number">5'd24</span>: test_data &lt;= rf[<span class="number">24</span>];</span><br><span class="line">            <span class="number">5'd25</span>: test_data &lt;= rf[<span class="number">25</span>];</span><br><span class="line">            <span class="number">5'd26</span>: test_data &lt;= rf[<span class="number">26</span>];</span><br><span class="line">            <span class="number">5'd27</span>: test_data &lt;= rf[<span class="number">27</span>];</span><br><span class="line">            <span class="number">5'd28</span>: test_data &lt;= rf[<span class="number">28</span>];</span><br><span class="line">            <span class="number">5'd29</span>: test_data &lt;= rf[<span class="number">29</span>];</span><br><span class="line">            <span class="number">5'd30</span>: test_data &lt;= rf[<span class="number">30</span>];</span><br><span class="line">            <span class="number">5'd31</span>: test_data &lt;= rf[<span class="number">31</span>];</span><br><span class="line">            <span class="keyword">default</span> : test_data &lt;= <span class="number">32'd0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4 id="其它过程"><a href="#其它过程" class="headerlink" title="其它过程"></a>其它过程</h4><blockquote>
<p>对于整个迁移的其它过程，都主要是按照接口来做，没有什么特别的地方需要说明。</p>
<p>另外需要说明的一点是，在机组实现的流水线cpu中，是在整个cpu的总线中进行调用inst_sram和data_sram，而在国科大的lab中，由更高一层的soc_lite_top.v进行调用和控制，而my_cpu中只需要调用fetch,decode,exe,mem,wb以及regfile进行执行即可。</p>
</blockquote>
<h4 id="IP核锁定解决方案"><a href="#IP核锁定解决方案" class="headerlink" title="IP核锁定解决方案"></a>IP核锁定解决方案</h4><blockquote>
<p>由于从旧的vivado版本迁移到新的版本中，会遇到IP核锁定的问题，所以我跑simulation的时候，发现跑不过，我开始以为是coe文件的问题，后来重新导入coe文件后，发现还是报错，于是我发现，是IP核锁定了。</p>
<p>首先查看网上的解决方案，在工具栏找到report-&gt;Report IP Status,然后发现没办法upgrade selected,这个时候点击右键，可以发现有UPGRADE IP的选项，果断选择，然后好像就OK了。容我跑一跑simulation(时间有点长，现在很慌~~)什么信息也不报一个</p>
</blockquote>
<h4 id="其它还需要修改的错误"><a href="#其它还需要修改的错误" class="headerlink" title="其它还需要修改的错误"></a>其它还需要修改的错误</h4><p>wb端实际上还需要修改，同时，并没有将所有需要的output实现，目前还有很多X与Z的存在，需要进一步修改其中的代码。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/23/龙芯杯6/" data-id="cjutpp51z0016rstqsa5c218x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/computer-system/">computer_system</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ma_model_pre5" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/28/ma_model_pre5/" class="article-date">
  <time datetime="2019-03-28T13:31:55.000Z" itemprop="datePublished">2019-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/28/ma_model_pre5/">ma_model_preparation5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h1><p>关于SVM的内容介绍，主要参考了这位博主的SVM文章<a href="http://www.blogjava.net/zhenandaci/category/31868.html" target="_blank" rel="noopener">点击此处进行查看</a>（讲得太好了）</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>支持向量机(Support Vector Machine)是Cortes和Vapnik于1995年首先提出的，它在解决小样本、非线性及高维模式识别中表现出许多特有的优势，并能够推广应用到函数拟合等其他机器学习问题中.</p>
<p>支持向量机方法是建立在统计学习理论的VC维理论和结构风险最小原理基础上的，根据有限的样本信息在模型的复杂性（即对特定训练样本的学习精度，Accuracy）和学习能力（即无错误地识别任意样本的能力）之间寻求最佳折衷，以期获得最好的推广能力（泛化能力）<br>所谓VC维是对函数类的一种度量，可以简单的理解为问题的复杂程度，VC维越高，一个问题就越复杂。正是因为SVM关注的是VC维，后面我们可以看到，SVM解决问题的时候，和样本的维数是无关的（甚至样本是上万维的都可以，这使得SVM很适合用来解决文本分类的问题，当然，有这样的能力也因为引入了核函数）。</p>
<p>与问题真实解之间的误差，就叫做风险（更严格的说，误差的累积叫做风险）。统计学习因此而引入了泛化误差界的概念，就是指真实风险应该由两部分内容刻画，一是经验风险，代表了分类器在给定样本上的误差；二是置信风险，代表了我们在多大程度上可以信任分类器在未知文本上分类的结果。很显然，第二部分是没有办法精确计算的，因此只能给出一个估计的区间，也使得整个误差只能计算上界，而无法计算准确的值（所以叫做泛化误差界，而不叫泛化误差）。置信风险与两个量有关，一是样本数量，显然给定的样本数量越大，我们的学习结果越有可能正确，此时置信风险越小；二是分类函数的VC维，显然VC维越大，推广能力越差，置信风险会变大。<br>SVM 有如下的优点</p>
<blockquote>
<p>小样本  非线性  高维模式识别</p>
</blockquote>
<h2 id="2-数学定义"><a href="#2-数学定义" class="headerlink" title="2.数学定义"></a>2.数学定义</h2><h3 id="考虑线性分类器"><a href="#考虑线性分类器" class="headerlink" title="考虑线性分类器"></a>考虑线性分类器</h3><blockquote>
<p>假设线性分类函数 g(x)=wx+b ，当然，其中w,x,b 均为高维向量，那么，不妨假设以g(x)=0为分界面，对于每个$x_i$而言，即有$y_i=sign(g(x_i))$,那么$y_i$要么为1，要么为-1，如此，定义$\sigma_i =\frac{y_i*g(x_i)}{||w||_2}$ ,因此，实际上$\sigma = \sum_{i=1}^n {\sigma_i}$为所有的距离之和,因而，我们找到一个最好的分类的目标变为$min ||w||$,为了在后续过程中使得我们的计算简单，我们将目标函数变为</p>
</blockquote>
<script type="math/tex; mode=display">min  \frac{1}{2}||w||^2</script><blockquote>
<p>但如若着这样，会存在一个问题，即分类的结果都会存在于两个分类器的中间地带，那么这样会导致$||w||=0$实际上不是我们需要的值，故在此基础上，我们还需要加上约束条件$y_i*g(x_i)&gt;=1(i=1,2,\ldots,n)$ 故，最终结果表示为</p>
</blockquote>
<script type="math/tex; mode=display">min \quad  \frac{1}{2}||w||^2</script><script type="math/tex; mode=display">subject\quad to: \quad y_i*g(x_i)-1>=0 \,\,(i=1,2,\ldots,n)</script><blockquote>
<p>实际上，这里的问题变为了一个凸优化问题，同时也是一个二次规划问题。我们知道，这样一个凸的规划问题，完全可以求得最优解，故我们的问题能够得到实际上的解决。那么需要怎么解决呢？</p>
</blockquote>
<h2 id="3-问题解决"><a href="#3-问题解决" class="headerlink" title="3.问题解决"></a>3.问题解决</h2><blockquote>
<p>实际上，我们求解的目标就是w，因为求得了w之后，可以求得b，则最终可以求到我们想要得到的g(x)这个函数，也就是分界面。而实际上，w与样本有关，那么我们可以定义$w=a_1x_1+a_2x_2+\ldots+a_nx_n$ 其中$a$为拉格朗日乘子，那么再次回顾$g(x)=\vec{w} \cdot \vec{x} +\vec{b}$,再次分析$\vec{w}$ 的表达式，我们可以发现，依然有错误，实际上，w还与y有关，故，我们可以将w这样表示</p>
</blockquote>
<script type="math/tex; mode=display">\vec{w}=\sum_{i=1}^n{(a_iy_ix_i)}</script><blockquote>
<p>因此 $g(x) =<w,x> +b= \sum_{i=1}^n{(a_iy_i<x_i,x>)}+b$,因此我们可以看到，我们实际上把w给消掉了，没有了w，实际上也减少了很多约束条件，接下来，我们将开始很重要的一个介绍，核函数</x_i,x></w,x></p>
</blockquote>
<h2 id="4-核函数"><a href="#4-核函数" class="headerlink" title="4.核函数"></a>4.核函数</h2><blockquote>
<p>一个解决线性不可分问题的基本思路————向高维空间转化，使其变得线性可分（一个二维空间中的问题，当映射到四维空间中的时候，就变得线性可分了），然而于此同时，也出现了很多问题，例如对于一个文本分类问题，将其映射到上万维的空间中，依旧是线性不可分的，然而，对于高维空间的计算，需要耗费大量的计算资源，因此，这就带来了不可计算的问题（这是实际工程中的一个重要的问题）</p>
<p>因此我们的目标已经明确了，找到一种能够映射到很高维的方法（要是能到无穷维就更好了！），并且能保证其在有限时间中可计算（如果能与没有升维之前有同样的计算阶那就再好不过了，即是线性的）。因此我们幻想，是否能有这样一种函数K(w,x),他接受低维空间的输入值，却能算出高维空间的内积值<w’,x’>。我们不妨假设这个函数为核函数K，那么即有</w’,x’></p>
</blockquote>
<script type="math/tex; mode=display">g(x)=K(w,x)+b\\
f(x')=<w',x'>+b</script><blockquote>
<p>这两个函数完全相等。因此，我们的目标变为了对非线性的分类问题，有$g(x)=\sum_{i=1}^n a_iy_i<x_i',x'>+b$<br>那么核函数(kernel)存在吗？万幸的是，这样的K(w,x)确实存在（发现凡是我们人类能解决的问题，大都是巧得不能再巧，特殊得不能再特殊的问题，总是恰好有些能投机取巧的地方才能解决，由此感到人类的渺小），它被称作核函数（核，kernel），而且还不止一个，事实上，只要是满足了Mercer条件的函数，都可以作为核函数。核函数的基本作用就是接受两个低维空间里的向量，能够计算出经过某个变换后在高维空间里的向量内积值。<br>常用的核函数有哪些呢？这里可以直接参考这一篇<a href="https://blog.csdn.net/batuwuhanpei/article/details/52354822" target="_blank" rel="noopener">blog</a>，常用的核函数有四个，分别为线性核函数,多项式核函数，高斯(RBF)核函数与sigmoid核函数,对于其的比较，我在这里就不区分了，在实践中，多用，就能更好地理解这几个核函数的区别。</x_i',x'></p>
</blockquote>
<h2 id="5-其它问题"><a href="#5-其它问题" class="headerlink" title="5.其它问题"></a>5.其它问题</h2><blockquote>
<p>我们必须再次思考其它的问题，即如果使用核函数向高维空间映射后，问题仍然是线性不可分的，那怎么办？</p>
<p>这一问题实际上我们可以理解为噪声问题，在实际过程中，我们所采集到的数据通常都会有噪声，那么，噪声会改变我们本来正确的分类结果，对程序而言，会导致一种情况，即我们无法对这样的数据，甚至映射到高维空间中后，也线性不可分。那么如何抑制此现象的产生呢？这实际上与我们之前提出的思路有极大的关联，即我们之前给出定义为</p>
</blockquote>
<script type="math/tex; mode=display">y_i[(wx_i)+b]>=1\quad(i=1,2,\ldots,n)</script><blockquote>
<p>这实际上要求了所有的点，均必须满足这一条件，那么这会导致不可分（纵然在极高维的空间中，或许它也可分，但所分出来的结果必然是过拟合的，而不是我们想要的），所以我们模仿人类的思想，只保证绝大多数分类正确，因此,我们给这个阈值加上一个松弛变量，使得原式变为：</p>
</blockquote>
<script type="math/tex; mode=display">y_i[(wx_i)+b]>=1-\zeta_i \quad (i=1,2,\ldots,n)</script><blockquote>
<p>在此基础上，我们的优化问题的目标有所改变</p>
</blockquote>
<script type="math/tex; mode=display">min \quad \frac{1}{2}||w||^2+C\sum_{i=1}^n{\zeta_i}\\
subject \quad to \quad y_i[(wx_i)+b]\geq 1-\zeta_i \quad(i=1,2,\ldots,n)\\
 \zeta_i\geq0</script><blockquote>
<p>其中，C是一个超参数，建议设一组值来进行尝试。这里在具体对C进行一个讨论，C是一个固定参数，对此可以这样理解，如果C设置得较大，则说明我们很care那些被丢弃掉的点，如果我们不care那些点的话，我们则可以将C设置得小一点，同时，我们也能对不同的点设置不同的C，那么，则代表我们对某些点有特殊的偏好,这被称作数据集偏斜。对于特定的问题，读者应该对C的设置有不同的思考，要把握C的实质内容。</p>
</blockquote>
<h2 id="6-将SVM用于多类分类"><a href="#6-将SVM用于多类分类" class="headerlink" title="6. 将SVM用于多类分类"></a>6. 将SVM用于多类分类</h2><blockquote>
<p>我们实际上可以将一个多分类问题，看做一个”一类对其余“的问题，那么每次仍然是解一个两类分类的问题。比如我们有5个类别，第一次就把类别1的样本定为正样本，其余2，3，4，5的样本合起来定为负样本，这样得到一个两类分类器，它能够指出一篇文章是还是不是第1类的；第二次我们把类别2 的样本定为正样本，把1，3，4，5的样本合起来定为负样本，得到一个分类器，如此下去，我们可以得到5个这样的两类分类器（总是和类别的数目一致）。到了有文章需要分类的时候，我们就拿着这篇文章挨个分类器的问：是属于你的么？是属于你的么？哪个分类器点头说是了，文章的类别就确定了。这种方法的好处是每个优化问题的规模比较小，而且分类的时候速度很快（只需要调用5个分类器就知道了结果）。但有时也会出现两种很尴尬的情况，例如拿一篇文章问了一圈，每一个分类器都说它是属于它那一类的，或者每一个分类器都说它不是它那一类的，前者叫分类重叠现象，后者叫不可分类现象。分类重叠倒还好办，随便选一个结果都不至于太离谱，或者看看这篇文章到各个超平面的距离，哪个远就判给哪个。不可分类现象就着实难办了，只能把它分给第6个类别了……更要命的是，本来各个类别的样本数目是差不多的，但“其余”的那一类样本数总是要数倍于正类（因为它是除正类以外其他类别的样本之和嘛），这就人为的造成了上一节所说的“数据集偏斜”问题。<br>因此，这样一个思路看上去可行，但实际上也需要一定的调整才能对实际的多分类问题进行应用。那需要哪些改善呢？还是解两类分类问题，还是每次选一个类的样本作正类样本，而负类样本则变成只选一个类（称为“一对一单挑”的方法，哦，不对，没有单挑，就是“一对一”的方法），这就避免了偏斜。但这样，会大量增加分类器的数量。<br>看来我们必须再退一步，在分类的时候下功夫，我们还是像一对一方法那样来训练，只是在对一篇文章进行分类之前，我们先按照下面图的样子来组织分类器（如你所见，这是一个有向无环图，因此这种方法也叫做DAG SVM）</p>
</blockquote>
<p><img src="https://github.com/leliyliu/ICM-MCM-preparation/blob/master/picture/clip_image002_thumb.gif?raw=true" alt="DAG SVM"></p>
<blockquote>
<p>这样在分类时,我们就可以先问分类器“1对5”（意思是它能够回答“是第1类还是第5类”），如果它回答5，我们就往左走，再问“2对5”这个分类器，如果它还说是“5”，我们就继续往左走，这样一直问下去，就可以得到分类结果。好处在哪？我们其实只调用了4个分类器（如果类别数是k，则只调用k-1个），分类速度飞快，且没有分类重叠和不可分类现象！缺点在哪？假如最一开始的分类器回答错误（明明是类别1的文章，它说成了5），那么后面的分类器是无论如何也无法纠正它的错误的（因为后面的分类器压根没有出现“1”这个类别标签），其实对下面每一层的分类器都存在这种错误向下累积的现象。</p>
<p>关于SMO算法的学习，在这里就不加以重点介绍，需要的可以参考<a href="https://www.cnblogs.com/bentuwuying/p/6444516.html" target="_blank" rel="noopener">SMO</a>这一篇博客</p>
</blockquote>
<h2 id="python-代码实现"><a href="#python-代码实现" class="headerlink" title="python 代码实现"></a>python 代码实现</h2><blockquote>
<p>在python中，scikit-learn是一个广泛使用的用于实现机器学习算法的库（也许后面我也会对这个库的使用方法作一系列的博客介绍），SVM算法可以在这个库中找到并用于实现。<br>这里的python实现借用了<a href="https://blog.csdn.net/u010665216/article/details/78382984" target="_blank" rel="noopener">blog</a>的实现方式，需要源码的也可以从中进行下载</p>
<p>sklearn中的SVC函数是基于libsvm实现的，所以在参数设置上有很多相似的地方。（PS: libsvm中的二次规划问题的解决算法是SMO）。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Import Library</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="comment">#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset</span></span><br><span class="line"><span class="comment"># Create SVM classification object </span></span><br><span class="line">model = svm.svc(kernel=<span class="string">'linear'</span>, c=<span class="number">1</span>, gamma=<span class="number">1</span>) </span><br><span class="line"><span class="comment"># there is various option associated with it, like changing kernel, gamma and C value. Will discuss more # about it in next section.Train the model using the training sets and check score</span></span><br><span class="line">model.fit(X, y)</span><br><span class="line">model.score(X, y)</span><br><span class="line"><span class="comment">#Predict Output</span></span><br><span class="line">predicted= model.predict(x_test)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.svm.SVC(C=<span class="number">1.0</span>, kernel=<span class="string">'rbf'</span>, degree=<span class="number">3</span>, gamma=<span class="number">0.0</span>, coef0=<span class="number">0.0</span>, shrinking=<span class="keyword">True</span>, probability=<span class="keyword">False</span>,tol=<span class="number">0.001</span>, cache_size=<span class="number">200</span>, class_weight=<span class="keyword">None</span>, verbose=<span class="keyword">False</span>, max_iter=<span class="number">-1</span>, random_state=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里展示了sklearn.svm.SVC的主要的参数，其中C为我们设置的超参数，而kernel有多种选择，这里为’rbf’,即高斯核函数。除此之外，还可以选择’linear’:线性核函数 ‘poly’ 多项式核函数 ‘sigmoid’ sigmoid核函数 ‘precomputed’:核矩阵（precomputed表示自己提前计算好核函数矩阵，这时候算法内部就不再用核函数去计算核矩阵，而是直接用你给的核矩阵。）</p>
<p>degree: int型参数 默认为3这个参数只对多项式核函数有用，是指多项式核函数的阶数n如果给的核函数参数是其他核函数，则会自动忽略该参数。</p>
<p>gamma: float参数 默认为auto核函数系数，只对‘rbf’,‘poly’,‘sigmod’有效。如果gamma为auto，代表其值为样本特征数的倒数，即1/n_features.</p>
<p>coef0: float参数 默认为0.0。核函数中的独立项，只有对‘poly’和‘sigmod’核函数有用，是指其中的参数c</p>
<p>probability： bool参数 默认为False。是否启用概率估计。 这必须在调用fit()之前启用，并且会fit()方法速度变慢。</p>
</blockquote>
<p>还有其它的参数，都可以参照<a href="https://blog.csdn.net/github_39261590/article/details/75009069" target="_blank" rel="noopener">svm参数说明</a>进行学习，这里就不再具体说明。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/28/ma_model_pre5/" data-id="cjutpp51w0014rstqc1qq5e02" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/math-model-preparation/">math_model_preparation</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ma_model_pre4" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/ma_model_pre4/" class="article-date">
  <time datetime="2019-03-22T01:12:32.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/22/ma_model_pre4/">ma_model_preparation1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="图与网络"><a href="#图与网络" class="headerlink" title="图与网络"></a>图与网络</h2><h3 id="basic-conception"><a href="#basic-conception" class="headerlink" title="basic conception"></a>basic conception</h3><pre><code>无向图 有向图 赋权图 有限图 简单图
完全图 二分图 子图 母图 顶点的度（入度，出度）
</code></pre><p>一个图称为<font color="blue">简单图(simple graph)</font>，如果它既没有环也没有两条边连接同一对顶点。</p>
<pre><code>邻接矩阵表示法  邻接链表表示法   弧表表示法   关联矩阵  星形表示法（前向和反向）
</code></pre><p><font color="0xffffff">弧表表示法</font>将图以弧表（arc list）的形式存储在计算机中。所谓图的弧表，也就是图的弧集合中的所有有序对。弧表表示法直接列出所有弧的起点和终点，共需2m个存储单元，因此当网络比较稀疏时比较方便。</p>
<p><font color="0xffffff">也就是说，在关联矩阵中，每行对应于图的一个节点，每列对应于图的一条弧。</font>如果一个节点是一条弧的起点，则关联矩阵中对应的元素为1；如果一个节点是一条弧的终点，则关联矩阵中对应的元素为−1；如果一个节点与一条弧不关联，则关联矩阵中对应的元素为 0。</p>
<pre><code>道路(walk) 迹(trail) 轨(path) 圈(cycle)
</code></pre><p>一个连通图的生成树很多,用 $\tau(G)$ 来表示图的生成树的个数，则有如下公式：</p>
<script type="math/tex; mode=display">\tau(K_n)=n^{n-2}</script><script type="math/tex; mode=display">\tau(G)=\tau(G-e)+\tau(G\cdot e)</script><h3 id="匹配问题"><a href="#匹配问题" class="headerlink" title="匹配问题"></a>匹配问题</h3><h4 id="1-几个定义"><a href="#1-几个定义" class="headerlink" title="1.几个定义"></a>1.几个定义</h4><p> 对集  匹配   完美对集    最大对集  交错轨  可增广轨</p>
<h4 id="2-定理"><a href="#2-定理" class="headerlink" title="2.定理:"></a>2.定理:</h4><p>(1)M是图G的最大对集当且仅当G中无M可增广轨</p>
<p>(2)G 为二分图， X与Y是顶点集的划分，G中存在把X中顶点皆许配的对集的充要条件是，∀S ⊂ X ，则|N(S)|≥|S|，其中N(S)是S中顶点的邻集。</p>
<blockquote>
<p>推论 若G是k次正则二分图（每个顶点皆K度的图），则G有完美对集</p>
</blockquote>
<h4 id="3-人员分派问题"><a href="#3-人员分派问题" class="headerlink" title="3.人员分派问题"></a>3.人员分派问题</h4><p>1.匈牙利算法：利用匈牙利算法可以直接解决人员分派问题，其思路非常简单，故在这里不做介绍。</p>
<p>2.-&gt;最优分派问题<br>这个问题的数学模型是：在人员分派问题的模型中，图 G 的每边加了权$w(x_i,y_j)&gt;=0$表示$x_i$干$y_j$ 工作的效益，求加权图G 上的权最大的完美对集。</p>
<p>解决这个问题可以参照<a href="http://vdisk.weibo.com/s/D8miedWz2uXT" target="_blank" rel="noopener">《数学建模算法与应用》（司守奎）</a>（P84）所给出的定义以及Kuhn-Munkres算法，其实质上是在匈牙利算法的进一步改善<br>如果想要对KM算法作深入的理解，可以参考这个<a href="https://blog.csdn.net/liu_y_r/article/details/79219405?utm_source=blogxgwz7" target="_blank" rel="noopener">blog</a></p>
<p>可行顶标$l$,对于任意弧,满足$e(x \rightarrow y)  都有 l_x+l_y\ge w_e$，后定义相等子图，其包含所有的点，但只包含满足$l_x+l_y=w_e$的所有弧$e(x \rightarrow y)$,这些弧已经是最大的弧，如果有完美匹配，那么可以得到最优分派。KM 算法仅仅只适用于找二分图最佳完美匹配，如果无完美匹配，那么算法很可能陷入死循环（如果不存在的边为 -INF 的话就不会，但正确性就无法保证了），对于这种情况要小心处理。</p>
<h4 id="4-Euler-图和Hamilton-图"><a href="#4-Euler-图和Hamilton-图" class="headerlink" title="4. Euler 图和Hamilton 图"></a>4. Euler 图和Hamilton 图</h4><p>1.基本概念</p>
<p>经过G 的每条边的迹叫做G 的Euler 迹；闭的Euler 迹叫做Euler 回路或E<br>回路；含Euler 回路的图叫做Euler 图。</p>
<p>定理<br>（i）G 是Euler 图的充分必要条件是G 连通且每顶点皆偶次。</p>
<p>（ ii ） G 是Euler 图的充分必要条件是G 连通且$G=\bigcup_{i=1}^dC_i,C_i$是圈，$E（C_i)\bigcap E(C_j)(i \neq j)$</p>
<p>（iii）G 中有Euler 迹的充要条件是G 连通且至多有两个奇次点。</p>
<p>包含G 的每个顶点的轨叫做Hamilton(哈密顿)轨；闭的Hamilton 轨叫做Hamilton 圈或H 圈；含Hamilton 圈的图叫做Hamilton 图。</p>
<p>Fleury 算法给出了求Euler 回路的算法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/ma_model_pre4/" data-id="cjutpp51q0010rstqam7bkxc6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/math-model-preparation/">math_model_preparation</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ma_model_pre3" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/15/ma_model_pre3/" class="article-date">
  <time datetime="2019-03-15T02:05:27.000Z" itemprop="datePublished">2019-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/15/ma_model_pre3/">ma_model_preparation2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-蒙特卡洛方法"><a href="#1-蒙特卡洛方法" class="headerlink" title="1. 蒙特卡洛方法"></a>1. 蒙特卡洛方法</h3><h4 id="（1）基本思路："><a href="#（1）基本思路：" class="headerlink" title="（1）基本思路："></a>（1）基本思路：</h4><p>蒙特卡罗方法是一种计算方法。原理是通过大量随机样本，去了解一个系统，进而得到所要计算的值。</p>
<h4 id="（2）一种应用：利用蒙特卡洛方法求积分："><a href="#（2）一种应用：利用蒙特卡洛方法求积分：" class="headerlink" title="（2）一种应用：利用蒙特卡洛方法求积分："></a>（2）一种应用：利用蒙特卡洛方法求积分：</h4><p>假设我们需要求这样一个图的积分<br><img src="https://github.com/leliyliu/ICM-MCM-preparation/blob/master/picture/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%B1%82%E7%A7%AF%E5%88%861.png?raw=true" alt="求积分图1"><br>那么实际上，我们所需要的过程可以表示如下<br><img src="https://github.com/leliyliu/ICM-MCM-preparation/blob/master/picture/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%B1%82%E7%A7%AF%E5%88%862.png?raw=true" alt="求积分过程"></p>
<p>从这两个过程中，我们可以看到，实际上对于积分的求解可以简化为这样一个过程：<br><br>假设要计算的积分如下：</p>
<script type="math/tex; mode=display">I=\int_{a}^{b}g(x)\text{d}x</script><p>那么如果选择一个概率密度函数为$f_X(x)$的方式进行抽样,并且满足$\int_{a}^{b}f_X(x)\text{d}x=1$,那么令$g^*(x)=\frac{g(x)}{f_X(x)}$,原有的积分可以写成如下形式：</p>
<script type="math/tex; mode=display">I=\int_{a}^{b}g^*(x)f_X(x)\text{d}x</script><p>故，我们求积分的步骤为：<br><br><br>1.产生服从分布律$F_X$的随机变量$X_i(i=1,2,…,N)$</p>
<p>2.计算均值</p>
<script type="math/tex; mode=display">\overline{I}=\frac{1}{N}\sum_{i=1}^ng^*(X_i)</script><p>一般采用均匀分布求解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calpai</span><span class="params">()</span>:</span></span><br><span class="line">    n = <span class="number">1000000</span></span><br><span class="line">    r = <span class="number">1.0</span></span><br><span class="line">    a, b = (<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">    x_neg, x_pos = a - r, a + r</span><br><span class="line">    y_neg, y_pos = b - r, b + r</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):</span><br><span class="line">        x = random.uniform(x_neg, x_pos)</span><br><span class="line">        y = random.uniform(y_neg, y_pos)</span><br><span class="line">        <span class="keyword">if</span> x*x + y*y &lt;= <span class="number">1.0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> (count / float(n)) * <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h4 id="3-蒙特卡洛树搜索"><a href="#3-蒙特卡洛树搜索" class="headerlink" title="(3)蒙特卡洛树搜索"></a>(3)蒙特卡洛树搜索</h4><p>as we know, an important method used in alpha go and alpha zero is Monte Carlo Tree search. So if you want to know more about this method, you can search this <a href="https://blog.csdn.net/qq_16137569/article/details/83543641" target="_blank" rel="noopener">website(Monte Carlo Tree search)</a> and get some knowledge yourself. also, you can get information in almost every game theory book.And try to get the big idea in Monte Carlo Tree search.</p>
<h3 id="2-马尔科夫链"><a href="#2-马尔科夫链" class="headerlink" title="2. 马尔科夫链"></a>2. 马尔科夫链</h3><h5 id="2-1-马尔可夫链的定义"><a href="#2-1-马尔可夫链的定义" class="headerlink" title="2.1 马尔可夫链的定义"></a>2.1 马尔可夫链的定义</h5><p>现实世界中有很多这样的现象：某一系统在已知现在情况的条件下，系统未来时刻<br>的情况只与现在有关，而与过去的历史无直接关系。比如，研究一个商店的累计销售额，<br>如果现在时刻的累计销售额已知，则未来某一时刻的累计销售额与现在时刻以前的任一<br>时刻累计销售额无关。上节中的几个例子也均属此类。描述这类随机现象的数学模型称<br>为马氏模型。</p>
<p>对于马尔科夫链的数学定义，可以直接参照<a href="http://vdisk.weibo.com/s/D8miedWz2uXT" target="_blank" rel="noopener">《数学建模算法与应用》（司守奎）</a>。</p>
<h5 id="2-2-马尔科夫链的性质"><a href="#2-2-马尔科夫链的性质" class="headerlink" title="2.2 马尔科夫链的性质"></a>2.2 马尔科夫链的性质</h5><p>转移概率矩阵及柯尔莫哥洛夫定理</p>
<p>对于这个性质，可以查看我给出的<a href="https://github.com/leliyliu/ICM-MCM-preparation/blob/master/learning_code/morkov.py" target="_blank" rel="noopener">代码morkov.py</a>进行了解</p>
<h5 id="2-3-马尔科夫链的应用"><a href="#2-3-马尔科夫链的应用" class="headerlink" title="2.3 马尔科夫链的应用"></a>2.3 马尔科夫链的应用</h5><p>虽然马尔科夫链的性质极其简单，但是其应用广泛，有着极大的意义。<br>应用马尔可夫链的计算方法进行马尔可夫分析，主要目的是根据某些变量现在的情<br>况及其变动趋向，来预测它在未来某特定区间可能产生的变动，作为提供某种决策的依<br>据。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/15/ma_model_pre3/" data-id="cjutpp51y0015rstq3m1upi0p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/math-model-preparation/">math_model_preparation</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ma-model-preparation1" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/09/ma-model-preparation1/" class="article-date">
  <time datetime="2019-03-09T02:05:27.000Z" itemprop="datePublished">2019-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/09/ma-model-preparation1/">ma_model_preparation1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="math-modeling-competition-for-2019-preparation"><a href="#math-modeling-competition-for-2019-preparation" class="headerlink" title="math_modeling competition for 2019 preparation"></a>math_modeling competition for 2019 preparation</h1><hr>
<h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract:"></a>abstract:</h2><pre><code>I&#39;d like to record my preparation for this competition, including some tricks on coding, and comperhension on some important math models and algorithms. Also, I&#39;d like to share some interesting tools we can use, such as Gephi, Citespace, and so on.
Meanwhile, I may record some basic knowledge on machine learning and data mining, even includes tensorflow and pytorch framework. So this series will be a hodgepodge of quite many things and knowledge. I hope I can truly learn something by doing so, and also help you work better.
</code></pre><h2 id="part-one"><a href="#part-one" class="headerlink" title="part one"></a>part one</h2><h3 id="EA-Evolutionary-Algorithms"><a href="#EA-Evolutionary-Algorithms" class="headerlink" title="EA (Evolutionary Algorithms)"></a>EA (Evolutionary Algorithms)</h3><h4 id="1-introduce"><a href="#1-introduce" class="headerlink" title="1. introduce"></a>1. introduce</h4><p>there are so many algorithms use the idea of evolution, and in the competition of math modeling, it’s so important that almost every time, we can slove a problem using it. </p>
<p>these algorithms include genetic algorithm, ant colony algorithm, Annealing Algorithm, neural network, tabu search and so on. I’d like to put focus on genetic algorithm this time, but I’ll also give some abstract on other algorithms. Also, codes will be shared on this <a href="https://github.com/leliyliu/ICM-MCM-preparation" target="_blank" rel="noopener">website</a> </p>
<h4 id="2-genetic-algorithm"><a href="#2-genetic-algorithm" class="headerlink" title="2. genetic algorithm"></a>2. genetic algorithm</h4><h5 id="1-流程图-flow-chart"><a href="#1-流程图-flow-chart" class="headerlink" title="1. 流程图(flow chart)"></a>1. 流程图(flow chart)</h5><p><img src="https://github.com/leliyliu/ICM-MCM-preparation/blob/master/picture/gen1.jpg?raw=true" alt="流程图"></p>
<h5 id="2-problem-needs-sloving"><a href="#2-problem-needs-sloving" class="headerlink" title="2.problem needs sloving"></a>2.problem needs sloving</h5><pre><code>maxf(x1,x2) = 21.5+x1*sin(4*pi*x1)+x2*sin(20*pi*x2)

                     s.t. -3.0&lt;=x1&lt;=12.1

                            4.1&lt;=x2&lt;=5.8
</code></pre><p>so we’d like to slove this problem using genetic algorithm, to better understand the process of this great algorithm.</p>
<h5 id="3-the-big-ideas"><a href="#3-the-big-ideas" class="headerlink" title="3.the big ideas"></a>3.the big ideas</h5><p>basic ideas:</p>
<ol>
<li>适应度函数(to compute the performance)<br> <br>适应度函数能够有效帮助后续的选择过程，进行有条件的保留与选择，帮助进行有效的迭代</li>
<li>交叉(crossover)<br> <br>针对不同的问题有不同的交叉方式，在交叉过程中需要注意保持原有数据的真实性，不能出现超越规则之外的数据。通常，我们设置crossover rate=0.8，能够有效地帮助进行迭代，较快且较好地收敛</li>
<li>变异(mutation)<br> <br>我们一般设置mutation rete=1/L(L: len of vector)，变异能减少收敛到局部最优的可能性，使得整个算法有更好的优化性，能够得到较好的结果</li>
<li>选择(selection)<br> <br>选择是遗传算法中一个非常重要的步骤，通常，选择的方式有多种(including roulette wheel selection, rank selection, tournament selection and Elitism + Offspring selection )，根据不同的问题，采用不同的选择方式，能够得到较好的结果。在这个问题中，我们采用轮盘赌算法来进行选择（关于轮盘赌算法的讲解，你可以查看<a href="https://blog.csdn.net/pymqq/article/details/51375522" target="_blank" rel="noopener">轮盘赌算法</a>)<h5 id="4-the-code-on-this-problem"><a href="#4-the-code-on-this-problem" class="headerlink" title="4. the code on this problem"></a>4. the code on this problem</h5>you can find the code on my github repository <a href="https://github.com/leliyliu/ICM-MCM-preparation" target="_blank" rel="noopener">MCM/ICM preparation</a>, I save the python code on the floder learning_code.<br>Because of the code is a little complicated, so maybe I’ll write down another blog or ipython to denote some details about this process. </li>
</ol>
<h4 id="other-basic-algorithms"><a href="#other-basic-algorithms" class="headerlink" title="other basic algorithms"></a>other basic algorithms</h4><h5 id="1-粒子群算法（蚁群算法）"><a href="#1-粒子群算法（蚁群算法）" class="headerlink" title="1. 粒子群算法（蚁群算法）"></a>1. 粒子群算法（蚁群算法）</h5><p>在使用蚁群算法求解现实问题时，先生成具有一定数量蚂蚁的蚁群，让每一只蚂<br>蚁建立一个解或解的一部分，每只人工蚁从问题的初始状态出发，根据“激素”浓度来<br>选择下一个要转移到的状态，直到建立起一个解，每只蚂蚁根据所找到的解的好坏程度<br>在所经过的状态上释放与解的质量成正比例的“激素”。之后，每只蚂蚁又开始新的求<br>解过程，直到寻找到满意解。为避免停滞现象，引入了激素更新机制。</p>
<h5 id="2-遗传退火算法"><a href="#2-遗传退火算法" class="headerlink" title="2. 遗传退火算法"></a>2. 遗传退火算法</h5><p>模拟退火算法得益于材料的统计力学的研究成果。统计力学表明材料中粒子的不<br>同结构对应于粒子的不同能量水平。在高温条件下，粒子的能量较高，可以自由运动和<br>重新排列。在低温条件下，粒子能量较低。如果从高温开始，非常缓慢地降温（这个过<br>程被称为退火），粒子就可以在每个温度下达到热平衡。当系统完全被冷却时，最终形<br>成处于低能状态的晶体。</p>
<p>在模拟退火算法中应注意以下问题：<br>（1）理论上，降温过程要足够缓慢，要使得在每一温度下达到热平衡。但在计算<br>机实现中，如果降温速度过缓，所得到的解的性能会较为令人满意，但是算法会太慢，<br>相对于简单的搜索算法不具有明显优势。如果降温速度过快，很可能最终得不到全局最<br>优解。因此使用时要综合考虑解的性能和算法速度，在两者之间采取一种折衷。<br>（2）要确定在每一温度下状态转换的结束准则。实际操作可以考虑当连续m 次的<br>转换过程没有使状态发生变化时结束该温度下的状态转换。最终温度的确定可以提前定<br>为一个较小的值e T ，或连续几个温度下转换过程没有使状态发生变化算法就结束。<br>（3）选择初始温度和确定某个可行解的邻域的方法也要恰当。</p>
<h5 id="3-禁忌搜索"><a href="#3-禁忌搜索" class="headerlink" title="3. 禁忌搜索"></a>3. 禁忌搜索</h5><p>禁忌搜索算法是组合优化算法的一种，是局部搜索算法的扩展。禁忌搜索算法是人<br>工智能在组合优化算法中的一个成功应用。禁忌搜索算法的特点是采用了禁忌技术。所<br>谓禁忌就是禁止重复前面的工作。禁忌搜索算法用一个禁忌表记录下已经到达过的局部<br>最优点，在下一次搜索中，利用禁忌表中的信息不再或有选择地搜索这些点。<br>禁忌搜索算法实现的技术问题是算法的关键。禁忌搜索算法涉及侯选集合、禁忌<br>对象、评价函数、特赦规则、记忆频率信息等概念。</p>
<h5 id="4-神经网络"><a href="#4-神经网络" class="headerlink" title="4. 神经网络"></a>4. 神经网络</h5><p>由于神经网络有极大的用途，一般会用其来进行深度学习，所以如果有时间的话，我会更新关于深度学习的部分博客用以记录和交流，故神经网络在这里不再提及。<br><br>当然，对于神经网络的搭建，现在已经有许多开源的框架，我在后续的博客中将使用pytorch框架，并尝试使用fastai 来实现相关的一些项目。</p>
<h5 id="5-all-in-all"><a href="#5-all-in-all" class="headerlink" title="5. all in all"></a>5. all in all</h5><p>我们已经看到了一个简单的遗传算法，就要使用上百行的python代码来实现，那么显然，既然在matlab 中有实现相关进化算法的框架，在python中同样也有，推荐的一个是geatpy。<br>你可以使用  </p>
<pre><code>pip install geatpy
</code></pre><p>来安装它。同时，你也可以通过这个网站<a href="https://github.com/geatpy-dev/geatpy" target="_blank" rel="noopener">geatpy</a>来学习具体的框架，希望它能帮助你更好地掌握进化算法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/09/ma-model-preparation1/" data-id="cjutpp51s0012rstqvnxc8tnc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/math-model-preparation/">math_model_preparation</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Modern-Anglo-American-philosophy-translation-11" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/Modern-Anglo-American-philosophy-translation-11/" class="article-date">
  <time datetime="2018-12-06T13:52:57.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/Modern-Anglo-American-philosophy-translation-11/">Modern Anglo-American philosophy translation_11</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Though meaningless, the propositions of logic and mathematics are not nonsense. They at least have the virtue of showing the essential structure of all possible facts. On the other hand, there are concatenations of words, purported propositions, that neither show nor say anything and thus are not connected to reality in any way. Such propositions are not merely senseless, they are nonsense. Among nonsense propositions are included the bulk of traditional philosophical statements articulating traditional philosophical problems and solutions, especially in metaphysics and ethics. This is the consequence of Wittgenstein’s presumption that meaningfulness is somehow linked to the realm of phenomena studied by the natural sciences (cf. 4.11 ff). Thus, as he claims in 6.53:</p>
</blockquote>
<p>尽管是缺少意义的，但是这个关于数学和逻辑的论题不是完全没有意义的。他们至少展示了所有可能的事情的必要的结构。另一方面，语词，命题的组合，并没有展示或者言说任何有关事实的东西。这些论题不仅仅是缺少意义的，而是毫无意义的。在这些毫无意义的论题中，包括了大部分表达传统哲学问题和解决方法的传统哲学陈述，特别是关于形而上学和伦理学的表述。基于维特根斯的推测，有意义的命题是和自然科学领域方面的现象相联系的。</p>
<blockquote>
<p>The correct method in philosophy would really be the following: to say nothing except what can be said, that is propositions of natural science—that is something that has nothing to do with philosophy—and then, whenever someone else wanted to say something metaphysical, to demonstrate to him that he had failed to give a meaning to certain signs in his propositions.</p>
</blockquote>
<p>哲学研究的正确方法如下：只说那些可以言说的部分，也就是关于自然科学的命题——而那正是哲学没有探讨的——然后，当某个人想要谈论任何关于形而上学的命题的时候，向他表明他无法给他命题中的某些符号特定的意义。</p>
<blockquote>
<p>In the eyes of its author (as he avers in its Introduction), the real accomplishment of the Tractatus was to have solved, or rather dissolved, all the traditional problems of philosophy by showing that they were meaningless conundrums generated by a failure to understand the limits of meaningful discourse.</p>
</blockquote>
<p>在逻辑哲学论作者的眼中（正如他在前言中所断言的那样），逻辑哲学论真正的成就就是解决了，或者更确切地说，通过展示这些所提出了缺乏意义的难题是由于错误地理解了有意义的论述的界限而消解了传统哲学的问题。</p>
<h3 id="3-Logical-Positivism-the-Vienna-Circle-and-Quine"><a href="#3-Logical-Positivism-the-Vienna-Circle-and-Quine" class="headerlink" title="3. Logical Positivism, the Vienna Circle, and Quine"></a>3. Logical Positivism, the Vienna Circle, and Quine</h3><hr>
<h4 id="a-Logical-Positivism-and-the-Vienna-Circle"><a href="#a-Logical-Positivism-and-the-Vienna-Circle" class="headerlink" title="a. Logical Positivism and the Vienna Circle"></a>a. Logical Positivism and the Vienna Circle</h4><blockquote>
<p>Logical positivism is the result of combining the central aspects of the positivisms of Auguste Comte and Ernst Mach with the meta-philosophical and methodological views of the analytic movement, especially as understood by the ideal-language camp. In all its forms, positivism was animated by the idealization of scientific knowledge as it was commonly understood from at least the time of Newton through the early twentieth century. Consequently, at its core is a view called scientism: the view that all knowledge is scientific knowledge.</p>
</blockquote>
<p>逻辑实证主义结合了孔德和马赫实证主义和分析哲学运动中的元哲学和方法论，特别是由理想语言阵营所理解的方法。在各种形式上，实证主义都将牛顿时代末期到二十世纪早期的常识认识作了一个科学知识的理想化。因此，实证主义的核心被称作是科学主义：即所有的知识都是科学知识的观点。</p>
<blockquote>
<p>As twentieth-century philosophy of science has shown, the definition and demarcation of science is a very difficult task. Still, for several centuries it has been common to presume that metaphysics and other branches of philosophy-as-traditionally-practiced, not to mention religious and “common sense” beliefs, do not qualify as scientific. From the standpoint of scientism, these are not fields of knowledge, and their claims should not be regarded as carrying any serious weight.</p>
</blockquote>
<p>正如二十世纪的科学哲学所展现的，很难对科学进行定义和划界。然而，几个世纪以来，在哲学界，有一个普遍的假定就是形而上学和其它传统哲学的实践分支，更不用提及宗教和“常识”信念，都不能称之为科学。根据科学主义的观点，这些领域是没有任何知识的，他们的言论不应该具有任何重要的意义。</p>
<blockquote>
<p>At the heart of logical positivism was a novel way of dismissing certain non-scientific views by declaring them not merely wrong or false, but meaningless. According to the verification theory of meaning, sometimes also called the empiricist theory of meaning, any non-tautological statement has meaning if and only if it can be empirically verified. This “verification principle” of meaning is similar to the principle maintained in Wittgenstein’s Tractatus that the realm of meaning is coextensive with the realm of the natural (empirical) sciences. In fact the logical positivists drew many of their views straight from the pages of the Tractatus (though their reading of it has since been criticized as being too inclined to emphasize the parts friendly to scientific naturalism at the expense of those less-friendly). With Wittgenstein, the logical positivists concluded that the bulk of traditional philosophy consisted in meaningless pseudo-problems generated by the misuse of language, and that the true role of philosophy was to establish and enforce the limits of meaningful language through linguistic analysis.</p>
</blockquote>
<p>逻辑实证主义的核心是提供了一种新的消解特定的非科学观点，其方法是指出他们不仅仅是正确或错误的，而是缺少意义的。根据关于意义的证实理论，也被称作关于意义的经验主义者理论，即任何非重言式的描述如果要有意义的话，当且仅当它可以被经验地证明。这个关于意义的实证原则和维特根斯坦的逻辑哲学论中所持有的意义的领域是与自然（经验）科学的领域是共同延伸的这一观点时相似的。事实上，逻辑实证主义者直接从逻辑哲学论的字里行间中取得了很多观点（尽管他们的理解被批评为过分强调了那些与科学自然主义相关的部分，而牺牲了其它没有太多关联的部分）。同维特根斯坦一样，逻辑实证主义者得出了大部分传统哲学都涉及到了误用语言而造成的缺乏意义的伪似的命题的结论，而哲学真正的作用是通过语言分析确立和加强有意义的语言的界限。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/06/Modern-Anglo-American-philosophy-translation-11/" data-id="cjutpp50d0004rstqcy7orw7r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Modern-Anglo-American-philosophy/">Modern Anglo-American philosophy</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Modern-Anglo-American-philosophy-translation-10" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/04/Modern-Anglo-American-philosophy-translation-10/" class="article-date">
  <time datetime="2018-12-04T15:08:43.000Z" itemprop="datePublished">2018-12-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/Modern-Anglo-American-philosophy-translation-10/">Modern Anglo-American philosophy translation_10</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>The body of the Tractatus consists in cascading levels of numbered elaborations of these propositions (1 is elaborated by 1.1 which is elaborated by 1.11, 1.12 and 1.13, and so forth)—except for 7, which stands on its own. Propositions 1 and 2 establish the metaphysical side of logical atomism: the world is nothing but a complex of atomic facts. Propositions 3 and 4 establish the isomorphism between language and reality: a significant (meaningful) proposition is a “logical picture” of the facts that constitute some possible or actual state of affairs. It is a picture in the sense that the structure of the proposition is identical to the structure of the corresponding atomic facts. It is here, incidentally, that we get the first explicit statement of the metaphilosophical view characteristic of early analytic philosophy: “All philosophy is a ‘critique of language’ …” (4.0031).</p>
</blockquote>
<p>逻辑哲学论的主体包括了多级详细阐述的关于命题的串联（1.1是用来详细解释1的，而1.11,1.12是用来详细解释1.1的，一直这样下去）——除了第七点，它只有这一句话。命题1和2建立了逻辑原子主义的形而上学方面的内容：这个世界只是原子事实的复合。命题3和4建立了语言和现实的同构：一个重要的（有意义的）命题是事实的一个“逻辑图像”，由一些可能的和实存的事态所组成。在某种意义上，它只是一个与相应的原子事实的结构相同的命题结构的图像。正是在这里，我们第一次了解到元哲学对于早期分析哲学的观点的说明：“所有的哲学都只是语言批判。”</p>
<blockquote>
<p>Proposition 5 asserts the thesis of truth-functionality, the view that all complex propositions are built out of atomic propositions joined by truth-functional connectives, and that atomic propositions are truth-functional in themselves. Even existentially quantified propositions are considered to be long disjunctions of atomic propositions. It has since been recognized that a truth-functional logic is not adequate to capture all the phenomena of the world; or at least that, if there is an adequate truth-functional system, we haven’t found it yet. Certain phenomena seem to defy truth-functional characterization; for instance, moral facts are problematic. </p>
</blockquote>
<p>命题5提出了真值函数的观点，其声称所有的复杂命题都是由连接词串联的原子命题所构成的，而原子命题本身是具有真值的。甚至存在量词命题也被认为是原子命题的长期析取。它开始意识到，一个具有真值意义的逻辑对于捕捉世界上所有的现象来说是不充分的，或者至少，我们还没有发现这样的真值系统。一些现象似乎是拒斥真值函数特征的；例如，道德事实就是不确定的。</p>
<blockquote>
<p>Knowing whether the constituent proposition “p” is true, doesn’t seem to tell us whether “It ought to be the case that p” is true. Similarly problematical are facts about thoughts, beliefs, and other mental states (captured in statements such as “John believes that…”), and modal facts (captured in statements about the necessity or possibility of certain states of affairs). And treating existential quantifiers as long disjunctions doesn’t seem to be adequate for the infinite number of facts about numbers since there surely are more real numbers than there are available names to name them even if we were willing to accept infinitely long disjunctions. The hope that truth-functional logic will prove adequate for resolving all these problems has inspired a good bit of thinking in the analytic tradition, especially during the first half of the twentieth century. This hope lies at the heart of logical atomism.</p>
</blockquote>
<p>认识到是否命题“p”的成分为真，似乎并不能使我们判别“这个事实p”为真。相似的不确定的事实是关于思想，信仰和一些其它的心理的（可以从陈述“约翰相信…”中看出），情感的状态（可以从关于具体事态的必然性和可能性的讨论中看出）。由于毫无疑问的，有远比我们可以命名的多得多的析取式，哪怕是我们愿意接受有无穷的析取式，因而将存在连词视作长析取式对于解释无穷的事态似乎是不充分的。</p>
<blockquote>
<p>In its full form, Proposition 6 includes some unusual symbolism that is not reproduced here.  All it does, however, is to give a general “recipe” for the creation of molecular propositions by giving the general form of a truth-function. Basically, Wittgenstein is saying that all propositions are truth-functional, and that, ultimately, there is only one kind of truth-function. Principia Mathematica had employed a number of truth-functional connectives: “and,” “or,” “not,” and so forth.  However, in 1913 a logician named Henry Sheffer showed that propositions involving these connectives could be rephrased (analyzed) as propositions involving a single connective consisting in the negation of a conjunction. </p>
</blockquote>
<p>在整本书中，命题6包括了一些不寻常的符号化，在这里将不会展示它们。所有的这些工作，只是为通过一种通用的真值形式来给分子命题的创造给出通用的“方法”。简单来说，维特根斯坦说所有的命题都具有真值，最终，就只有一种真值形式。数学原理提供了一系列的真值连词：“and”,”or”,”not”等等。然而，在1913年一个名为Henry Sheffer的逻辑学家展示到使用这些连词的命题都可以只使用一个单独的连词而不需要其它连词。</p>
<blockquote>
<p>This was called the “not and” or “nand” connective, and was supposed to be equivalent to the ordinary language formulation “not both x and y.” It is usually symbolized by a short vertical line ( | ) called the Sheffer stroke. Though Wittgenstein uses his own idiosyncratic symbolism, this is the operation identified in proposition 6 and some of its elaborations as showing the general form of a truth-function. Replacing the Principia’s plurality of connectives with the “nand” connective made for an extremely minimalistic system—all one needed to construct a complete picture/description of the world was a single truth-functional connective applied repeatedly to the set of all atomic propositions.</p>
</blockquote>
<p>它们被称为”not and” 或者”nand”，它的具体意义是和日常语言中的“不是 a和b”相同。它通常用一根竖线表示，这个符号被称为“Sheffer stroke”。尽管维特根斯坦使用了他自己特定的符号，这是命题6中所执行的方法，它的一些阐述显示了真理函数的一般形式。通过取代数学原理中多元的连词而采用”nand”来替代，构建了一个最小的系统——一个人要构建一个关于这个世界图像的描述，就仅仅是用一个连词连接的关于所有的原子命题的不同类型。</p>
<blockquote>
<p>Proposition 7, which stands on its own, is the culmination of a series of observations made throughout the Tractatus, and especially in the elaborations of proposition 6. Throughout the Tractatus there runs a distinction between showing and saying. Saying is a matter of expressing a meaningful proposition. Showing is a matter of presenting something’s form or structure. Thus, as Wittgenstein observes at 4.022, “A proposition shows its sense. A proposition shows how things stand if it is true. And it says that they do so stand.”</p>
</blockquote>
<p>命题7，是一个自成立的命题，是整个逻辑哲学论的高潮部分，特别是在建立了命题6之后。贯穿逻辑哲学论的是一条关于言说和展示的界限。言说是一种表达有意义的命题的方式。展示是一种<br>表现形式和结构的方式。因此，正如维特根斯坦在4.022中所表达的“一个命题展示了它的意义。一个命题展示了它是否为真。同时也言说了其为何为真。”</p>
<blockquote>
<p>In the introduction to the Tractatus, Wittgenstein indicates that his overarching purpose is to set the criteria and limits of meaningful saying. The structural aspects of language and the world—those aspects that are shown—fall beyond the limits of meaningful saying. According to Wittgenstein, the propositions of logic and mathematics are purely structural and therefore meaningless—they show the form of all possible propositions/states of affairs, but they do not themselves picture any particular state of affairs, thus they do not say anything. This has the odd consequence that the propositions of the Tractatus themselves, which are supposed to be about logic, are meaningless. Hence the famous dictum at 6.54:</p>
</blockquote>
<p>在逻辑哲学论的前言中，维特根斯坦说明了他首要的目的就是建立一个有意义的言说的标准。语言和世界的结构——那些所展示的部分——是在有意义的言说的界限之外的。根据维特根斯坦的说法，逻辑和数学的命题只是纯粹的结构上的，因此他们能够描述任何特定的事态，因此，它们什么也没有言说。这造成一个奇怪的现象，就是在逻辑哲学论中的那些论题本身，就是逻辑命题，因此也就是没有意义的。因此在6.54中，有一个著名的声明：</p>
<blockquote>
<p>My propositions are elucidatory in this way: he who understands me finally recognizes them as senseless, when he has climbed out through them, on them, over them. (He must so to speak throw away the ladder, after he has climbed up on it.) He must transcend these propositions, and then he will see the world aright.</p>
</blockquote>
<p>我的命题是以这样一种方式来阐明的：一个真正理解我的人最终会意识到我的命题是缺少意义的，当他登上他们，站在他们之上，并超越他们（他必须丢掉这个梯子，当他真正爬上去之后。）他必须超越这些命题，最终他将会看到真正的世界。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/04/Modern-Anglo-American-philosophy-translation-10/" data-id="cjutpp50k0009rstqcc6thabt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Modern-Anglo-American-philosophy/">Modern Anglo-American philosophy</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-github-use" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/01/github-use/" class="article-date">
  <time datetime="2018-12-01T07:50:10.000Z" itemprop="datePublished">2018-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/01/github-use/">github_use</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="github-使用，创建代码库并使用"><a href="#github-使用，创建代码库并使用" class="headerlink" title="github 使用，创建代码库并使用"></a>github 使用，创建代码库并使用</h2><hr>
<h3 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h3><pre><code>git clone + 地址  将github中的文件目录及库拷贝
</code></pre><h3 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h3><pre><code>git init 用于生成本地的git 管理
git add . 添加文件到git的本地中 如果想添加某个特定的文件，只需把.换成这个特定的文件名即可
输入git commit -m &#39;first commit&#39;，表示你对这次提交的注释，双引号里面的内容可以根据个人的需要修改。 
git remote add origin https://自己的仓库url地址
移除origin ———————— git remote rm origin 
git push -u origin master 上传到github 中
(当使用上面push时遇到错误时，1.git pull origin master
2.git pull --rebase origin master)
语句1.代表先进行pull，即下拉之后再进行上传
语句2.代表当本地与最新的库不同时，先进行保留，再上传。
</code></pre><h3 id="后续改动及理解"><a href="#后续改动及理解" class="headerlink" title="后续改动及理解"></a>后续改动及理解</h3><pre><code>git pull ,拉取当前分支最新代码
利用git status 查看git 仓库状态
git add * 更新全部 或者用git add -all
git push （在后续过程中，直接git push）即可
</code></pre><h4 id="附"><a href="#附" class="headerlink" title="附"></a>附</h4><p><a href="https://blog.csdn.net/u012661010/article/details/73433872/" target="_blank" rel="noopener">可参考博客</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/01/github-use/" data-id="cjutpp50y000krstqwhp75jsw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/github-git/">github/git</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MCM-ICM-preparation-two" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/01/MCM-ICM-preparation-two/" class="article-date">
  <time datetime="2018-12-01T07:03:01.000Z" itemprop="datePublished">2018-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/01/MCM-ICM-preparation-two/">MCM/ICM preparation -two</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MCM-ICM-preparation"><a href="#MCM-ICM-preparation" class="headerlink" title="MCM/ICM preparation"></a>MCM/ICM preparation</h1><h2 id="second-numpy-amp-pandas"><a href="#second-numpy-amp-pandas" class="headerlink" title="second(numpy &amp; pandas)"></a>second(numpy &amp; pandas)</h2><hr>
<h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><p>1.深浅拷贝</p>
<pre><code>深拷贝:a=np.array([...]) b=a   则b is a 为True  传的是引用
浅拷贝:b=a.copy()  则b is a 为Flase 
</code></pre><h3 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h3><p>1.对于pd.Series() 以及pd.DateFrame() 的使用</p>
<pre><code>对所生成的数据进行排序，进行数据的简单处理与查看，进行对于index 与 columns 的查看与使用, 按照index与colums的方式来进行排序的方法.
</code></pre><p>2.选择数据</p>
<pre><code>#select by label: df.loc  
#select by position: df.iloc
#select by mixed selection:df.ix(在新的pandas中，ix方式已经不建议被使用，将被移除)
#bool indexing  利用df.A&gt;num 来进行选择某些值
</code></pre><p>3.设置值</p>
<pre><code>利用iloc，loc，以及bool indexing来进行修改
直接添加一行或者一列，那么就可以直接用df[&#39;E&#39;]=...来进行添加
</code></pre><p>4.处理丢失数据</p>
<pre><code>df.dropna()   df.fillna()  df.isnull()   np.any(df.isnull==True)/df.isnull().any()
这四种方式对于丢失的数据进行处理，1.丢掉 2，填充 3、4.判断是否有丢失
</code></pre><p>5.储存数据<br>    read_csv/to_csv</p>
<p>6.合并数据</p>
<pre><code>利用concat([df1,df2,df3],axis=0,ignore_index=True)#aixs=0竖向合并
利用join参数  join=&#39;outer&#39;/&#39;inner&#39; 这两个如果是outer，则都显示,inner则只是显示都共有的index与columns
利用参数join_axes，按照某一个具体的来进行考虑
append()的方法,将具体某些加到原pandas中。

merge 
利用merge()函数中的on参数进行合并
注意on的参数类型可以使多样的，比如单独的一个是字符串，多个的话就是列表
合并的时候是用inner 的方式来进行的
注意indicator这个参数为True时能够展示合并的方式(left_only,both,right_only)
注意区别index 和column两个的合并，参数有一点小小的不同
添加标签-&gt; suffixes
</code></pre><p>7.pandas 绘图</p>
<pre><code>利用pandas直接plot(),不需要plt
对于scatter，是直接在plot()后的属性，而不是一个特别的方式。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/01/MCM-ICM-preparation-two/" data-id="cjutpp5080001rstq8joch3xr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MCM-ICM-preparation/">MCM/ICM preparation</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Modern-Anglo-American-philosophy-translation-9" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/28/Modern-Anglo-American-philosophy-translation-9/" class="article-date">
  <time datetime="2018-11-28T15:15:18.000Z" itemprop="datePublished">2018-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/28/Modern-Anglo-American-philosophy-translation-9/">Modern Anglo-American philosophy translation_9</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="d-Logical-Atomism-and-Wittgenstein’s-Tractatus"><a href="#d-Logical-Atomism-and-Wittgenstein’s-Tractatus" class="headerlink" title="d. Logical Atomism and Wittgenstein’s Tractatus"></a>d. Logical Atomism and Wittgenstein’s Tractatus</h3><blockquote>
<p>Ludwig Wittgenstein came to Cambridge to study mathematical logic under Russell, but he quickly established himself as his teacher’s intellectual peer. Together, they devised a metaphysical system called “logical atomism.” As discussed at the beginning of Section 2, qua total system, logical atomism seems to have been Wittgenstein’s brainchild. Still, this should not be seen as in any way marginalizing Russell’s significance for the system, which can be described as a metaphysics based on the assumption that an ideal language the likes of which was provided in Principia Mathematica is the key to reality.</p>
</blockquote>
<p>维特根斯坦来到剑桥向罗素学习数学逻辑，但他很快变为了他老师在研究中的同伴。他们在一起设计了一种被称作是“逻辑原子主义”的形而上学系统。正如在第二节开头所讨论的，作为一个完整的系统，逻辑原子论似乎是维特根斯坦所思考出来的。然而，这不应该被认作是罗素在这个系统中所做出的卓越的贡献，他基于一个在数学原理中类似的理想语言是与现实相联系的关键的猜想，而形成了一种形而上学的体系。</p>
<blockquote>
<p>According to logical atomism, propositions are built out of elements corresponding to the basic constituents of the world, just as sentences are built out of words. The combination of words in a meaningful sentence mirrors the combination of constituents in the corresponding proposition and also in the corresponding possible or actual state of affairs. That is, the structure of every possible or actual state of affairs is isomorphic with both the structure of the proposition that refers to it and the structure of the sentence that expresses that proposition—so long as the sentence is properly formulated in the notation of symbolic logic. The simplest sort of combination is called an atomic fact because this fact has no sub-facts as part of its structure. An atomic fact for some logical atomists might be something like an individual having a property—a certain leaf’s being green, for instance. Linguistically, this fact is represented by an atomic proposition: for example, “this leaf is green,” or, in logical symbolism “F(a).” Both the fact F(a) and the proposition “F(a)” are called “atomic” not because they themselves are atomic [that is, without structure], but because all their constituents are. Atomic facts are the basic constituents of the world, and atomic propositions are the basic constituents of language.</p>
</blockquote>
<p>根据逻辑原子主义，命题是由那些与世界的基本组成部分相联系的元素所构成的，就像语言是由单词构成的一样。在一句有意义的话中，单词的组合反映了命题相应的组成部分，同时也是事态的可能或实在的组成部分。即是说，每个事态的可能或实在的结构是与指向其的命题或者表达这个命题的语句同构的——正如语句被恰当地被转化为符号逻辑那样。最简单的组合被称为原子事实因为这类事实没有子事实来作为它的构成部分。一个原子事实对一些逻辑原子主义者来说就是一些只具有一种性质的单独个体——例如，一片特定的叶子是绿色的。从语言学角度看，这个事实是一个原子论点：例如“这片叶子是绿色的”，或者用符号逻辑“F(a)”来表示。不论是事实F(a)还是命题“F(a)”都被叫做“原子的”不仅仅是因为他们是原子的（即没有结构的），也是因为它的组成部分也是原子的。原子事实是这个世界最基本的组成部分，同时，原子命题是语言最基本的组成部分。</p>
<blockquote>
<p>More complex propositions representing more complex facts are called molecular propositions and molecular facts.  The propositions are made by linking atomic propositions together with truth-functional connectives, such as “and,” “or” and “not.” A truth-functional connective is one that combines constituent propositions in such a way that their truth-values (that is, their respective statuses as true or false) completely determine the truth value of the resulting molecular proposition. For instance, the truth value of a proposition of the form “not-p” can be characterized in terms of, and hence treated as determined by, the truth value of “p” because if “p” is true, then “not-p” is false, and if it is false, “not-p” is true. Similarly, a proposition of the form “p and q” will be true if and only if its constituent propositions “p” and “q” are true on their own.</p>
</blockquote>
<p>反映了更复杂的事实的复杂命题被称为分子命题和分子事实。这些命题利用像“and”，“or”和“not”这样的真值连词将原子命题联系起来。一个真值连词就是一个将组成命题的原子命题用一种方式串联起来的词，它使得分子命题的真值完全取决于原子命题的真值。例如，形如“not -p”的命题的真值可以按照，也由”p”的真值来决定，因为，当p为真时，“not -p”就是假，反之亦然。同样地，要使得”p and q”为真必须要组成这个命题的“p”和“q”同时为真。</p>
<blockquote>
<p>The logic of Principia Mathematica is entirely truth-functional; that is, it only allows for molecular propositions whose truth-values are determined by their atomic constituents. Thus, as Russell observed in the introduction to the second edition of the Principia, “given all true atomic propositions, together with the fact that they are all, every other true proposition can theoretically be deduced by logical methods” (Russell 1925, xv). The same assumption—called the thesis of truth-functionality or the thesis of extensionality—lies behind Wittgenstien’sTractatusLogico-Philosophicus.</p>
</blockquote>
<p>数学原理的逻辑就是一个完全真值表：即是，它只让分子命题的真实取决于组成它是原子命题。因此，当罗素在数学原理第二版的引言部分写道：“将所有为真的原子命题给出，和所有他们指向的原子事实，任何其他的真命题都可以利用逻辑方法推导出来”。同样的假设——被称作真值函数的论点或其外延性的论点——成为了维特根斯坦逻辑哲学论的基础。</p>
<blockquote>
<p>As mentioned previously, Wittgenstein’s Tractatus proved to be the most influential expression of logical atomism. The Tractatus is organized around seven propositions, here taken from the 1922 translation by C. K. Ogden:</p>
</blockquote>
<p>正如之前所提到的，维特根斯坦的逻辑哲学论被证明是在逻辑原子主义中最具影响力的著作。逻辑哲学论由骐达观点组成，这里采用了1922年C. K. Ogden翻译的版本：</p>
<blockquote>
<p>The world is everything that is the case.<br><br>What is the case, the fact, is the existence of atomic facts.<br><br>The logical picture of the facts is the thought.<br><br>The thought is the significant proposition.<br><br>Propositions are truth-functions of elementary propositions. (An elementary proposition is a truth function of itself.)<br><br>The general form of a truth-function is…. This is the general form of a proposition.<br><br>Where of one cannot speak, thereof one must be silent.</p>
</blockquote>
<p>1.世界是所发生的一切事情的总和<br><br>2.事态和事实就是原子事实的存在<br><br>3.事实的逻辑图像就是思想<br><br>4.思考是最重要的命题<br><br>5.命题是基本命题的真值函数（一个基本命题就是它自己的真值）<br><br>6.真值函数的一般形式即是命题的一般形式<br><br>7.对于不可言说者，必须保持沉默</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/28/Modern-Anglo-American-philosophy-translation-9/" data-id="cjutpp510000mrstqwglakxml" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Modern-Anglo-American-philosophy/">Modern Anglo-American philosophy</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/English-learning/">English_learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MCM-ICM-preparation/">MCM/ICM preparation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Modern-Anglo-American-philosophy/">Modern Anglo-American philosophy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Philosophy-of-Science/">Philosophy of Science</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/computer-system/">computer_system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github-git/">github/git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math-model-preparation/">math_model_preparation</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/English-learning/" style="font-size: 10px;">English_learning</a> <a href="/tags/MCM-ICM-preparation/" style="font-size: 13.33px;">MCM/ICM preparation</a> <a href="/tags/Modern-Anglo-American-philosophy/" style="font-size: 20px;">Modern Anglo-American philosophy</a> <a href="/tags/Philosophy-of-Science/" style="font-size: 10px;">Philosophy of Science</a> <a href="/tags/computer-system/" style="font-size: 16.67px;">computer_system</a> <a href="/tags/github-git/" style="font-size: 10px;">github/git</a> <a href="/tags/math-model-preparation/" style="font-size: 16.67px;">math_model_preparation</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/23/龙芯杯6/">longxin_6</a>
          </li>
        
          <li>
            <a href="/2019/03/28/ma_model_pre5/">ma_model_preparation5</a>
          </li>
        
          <li>
            <a href="/2019/03/22/ma_model_pre4/">ma_model_preparation1</a>
          </li>
        
          <li>
            <a href="/2019/03/15/ma_model_pre3/">ma_model_preparation2</a>
          </li>
        
          <li>
            <a href="/2019/03/09/ma-model-preparation1/">ma_model_preparation1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Leliyliu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>